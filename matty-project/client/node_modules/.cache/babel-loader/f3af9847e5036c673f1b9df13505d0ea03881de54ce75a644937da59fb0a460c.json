{"ast":null,"code":"import { Util } from \"./Util.js\";\nimport { Container } from \"./Container.js\";\nimport { Node } from \"./Node.js\";\nimport { Factory } from \"./Factory.js\";\nimport { SceneCanvas, HitCanvas } from \"./Canvas.js\";\nimport { getBooleanValidator } from \"./Validators.js\";\nimport { shapes } from \"./Shape.js\";\nimport { _registerNode } from \"./Global.js\";\nconst HASH = '#',\n  BEFORE_DRAW = 'beforeDraw',\n  DRAW = 'draw',\n  INTERSECTION_OFFSETS = [{\n    x: 0,\n    y: 0\n  }, {\n    x: -1,\n    y: -1\n  }, {\n    x: 1,\n    y: -1\n  }, {\n    x: 1,\n    y: 1\n  }, {\n    x: -1,\n    y: 1\n  }],\n  INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;\nexport class Layer extends Container {\n  constructor(config) {\n    super(config);\n    this.canvas = new SceneCanvas();\n    this.hitCanvas = new HitCanvas({\n      pixelRatio: 1\n    });\n    this._waitingForDraw = false;\n    this.on('visibleChange.konva', this._checkVisibility);\n    this._checkVisibility();\n    this.on('imageSmoothingEnabledChange.konva', this._setSmoothEnabled);\n    this._setSmoothEnabled();\n  }\n  createPNGStream() {\n    const c = this.canvas._canvas;\n    return c.createPNGStream();\n  }\n  getCanvas() {\n    return this.canvas;\n  }\n  getNativeCanvasElement() {\n    return this.canvas._canvas;\n  }\n  getHitCanvas() {\n    return this.hitCanvas;\n  }\n  getContext() {\n    return this.getCanvas().getContext();\n  }\n  clear(bounds) {\n    this.getContext().clear(bounds);\n    this.getHitCanvas().getContext().clear(bounds);\n    return this;\n  }\n  setZIndex(index) {\n    super.setZIndex(index);\n    const stage = this.getStage();\n    if (stage && stage.content) {\n      stage.content.removeChild(this.getNativeCanvasElement());\n      if (index < stage.children.length - 1) {\n        stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[index + 1].getCanvas()._canvas);\n      } else {\n        stage.content.appendChild(this.getNativeCanvasElement());\n      }\n    }\n    return this;\n  }\n  moveToTop() {\n    Node.prototype.moveToTop.call(this);\n    const stage = this.getStage();\n    if (stage && stage.content) {\n      stage.content.removeChild(this.getNativeCanvasElement());\n      stage.content.appendChild(this.getNativeCanvasElement());\n    }\n    return true;\n  }\n  moveUp() {\n    const moved = Node.prototype.moveUp.call(this);\n    if (!moved) {\n      return false;\n    }\n    const stage = this.getStage();\n    if (!stage || !stage.content) {\n      return false;\n    }\n    stage.content.removeChild(this.getNativeCanvasElement());\n    if (this.index < stage.children.length - 1) {\n      stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[this.index + 1].getCanvas()._canvas);\n    } else {\n      stage.content.appendChild(this.getNativeCanvasElement());\n    }\n    return true;\n  }\n  moveDown() {\n    if (Node.prototype.moveDown.call(this)) {\n      const stage = this.getStage();\n      if (stage) {\n        const children = stage.children;\n        if (stage.content) {\n          stage.content.removeChild(this.getNativeCanvasElement());\n          stage.content.insertBefore(this.getNativeCanvasElement(), children[this.index + 1].getCanvas()._canvas);\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  moveToBottom() {\n    if (Node.prototype.moveToBottom.call(this)) {\n      const stage = this.getStage();\n      if (stage) {\n        const children = stage.children;\n        if (stage.content) {\n          stage.content.removeChild(this.getNativeCanvasElement());\n          stage.content.insertBefore(this.getNativeCanvasElement(), children[1].getCanvas()._canvas);\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n  getLayer() {\n    return this;\n  }\n  remove() {\n    const _canvas = this.getNativeCanvasElement();\n    Node.prototype.remove.call(this);\n    if (_canvas && _canvas.parentNode && Util._isInDocument(_canvas)) {\n      _canvas.parentNode.removeChild(_canvas);\n    }\n    return this;\n  }\n  getStage() {\n    return this.parent;\n  }\n  setSize({\n    width,\n    height\n  }) {\n    this.canvas.setSize(width, height);\n    this.hitCanvas.setSize(width, height);\n    this._setSmoothEnabled();\n    return this;\n  }\n  _validateAdd(child) {\n    const type = child.getType();\n    if (type !== 'Group' && type !== 'Shape') {\n      Util.throw('You may only add groups and shapes to a layer.');\n    }\n  }\n  _toKonvaCanvas(config) {\n    config = {\n      ...config\n    };\n    config.width = config.width || this.getWidth();\n    config.height = config.height || this.getHeight();\n    config.x = config.x !== undefined ? config.x : this.x();\n    config.y = config.y !== undefined ? config.y : this.y();\n    return Node.prototype._toKonvaCanvas.call(this, config);\n  }\n  _checkVisibility() {\n    const visible = this.visible();\n    if (visible) {\n      this.canvas._canvas.style.display = 'block';\n    } else {\n      this.canvas._canvas.style.display = 'none';\n    }\n  }\n  _setSmoothEnabled() {\n    this.getContext()._context.imageSmoothingEnabled = this.imageSmoothingEnabled();\n  }\n  getWidth() {\n    if (this.parent) {\n      return this.parent.width();\n    }\n  }\n  setWidth() {\n    Util.warn('Can not change width of layer. Use \"stage.width(value)\" function instead.');\n  }\n  getHeight() {\n    if (this.parent) {\n      return this.parent.height();\n    }\n  }\n  setHeight() {\n    Util.warn('Can not change height of layer. Use \"stage.height(value)\" function instead.');\n  }\n  batchDraw() {\n    if (!this._waitingForDraw) {\n      this._waitingForDraw = true;\n      Util.requestAnimFrame(() => {\n        this.draw();\n        this._waitingForDraw = false;\n      });\n    }\n    return this;\n  }\n  getIntersection(pos) {\n    if (!this.isListening() || !this.isVisible()) {\n      return null;\n    }\n    let spiralSearchDistance = 1;\n    let continueSearch = false;\n    while (true) {\n      for (let i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {\n        const intersectionOffset = INTERSECTION_OFFSETS[i];\n        const obj = this._getIntersection({\n          x: pos.x + intersectionOffset.x * spiralSearchDistance,\n          y: pos.y + intersectionOffset.y * spiralSearchDistance\n        });\n        const shape = obj.shape;\n        if (shape) {\n          return shape;\n        }\n        continueSearch = !!obj.antialiased;\n        if (!obj.antialiased) {\n          break;\n        }\n      }\n      if (continueSearch) {\n        spiralSearchDistance += 1;\n      } else {\n        return null;\n      }\n    }\n  }\n  _getIntersection(pos) {\n    const ratio = this.hitCanvas.pixelRatio;\n    const p = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio), Math.round(pos.y * ratio), 1, 1).data;\n    const p3 = p[3];\n    if (p3 === 255) {\n      const colorKey = Util._rgbToHex(p[0], p[1], p[2]);\n      const shape = shapes[HASH + colorKey];\n      if (shape) {\n        return {\n          shape: shape\n        };\n      }\n      return {\n        antialiased: true\n      };\n    } else if (p3 > 0) {\n      return {\n        antialiased: true\n      };\n    }\n    return {};\n  }\n  drawScene(can, top, bufferCanvas) {\n    const layer = this.getLayer(),\n      canvas = can || layer && layer.getCanvas();\n    this._fire(BEFORE_DRAW, {\n      node: this\n    });\n    if (this.clearBeforeDraw()) {\n      canvas.getContext().clear();\n    }\n    Container.prototype.drawScene.call(this, canvas, top, bufferCanvas);\n    this._fire(DRAW, {\n      node: this\n    });\n    return this;\n  }\n  drawHit(can, top) {\n    const layer = this.getLayer(),\n      canvas = can || layer && layer.hitCanvas;\n    if (layer && layer.clearBeforeDraw()) {\n      layer.getHitCanvas().getContext().clear();\n    }\n    Container.prototype.drawHit.call(this, canvas, top);\n    return this;\n  }\n  enableHitGraph() {\n    this.hitGraphEnabled(true);\n    return this;\n  }\n  disableHitGraph() {\n    this.hitGraphEnabled(false);\n    return this;\n  }\n  setHitGraphEnabled(val) {\n    Util.warn('hitGraphEnabled method is deprecated. Please use layer.listening() instead.');\n    this.listening(val);\n  }\n  getHitGraphEnabled(val) {\n    Util.warn('hitGraphEnabled method is deprecated. Please use layer.listening() instead.');\n    return this.listening();\n  }\n  toggleHitCanvas() {\n    if (!this.parent || !this.parent['content']) {\n      return;\n    }\n    const parent = this.parent;\n    const added = !!this.hitCanvas._canvas.parentNode;\n    if (added) {\n      parent.content.removeChild(this.hitCanvas._canvas);\n    } else {\n      parent.content.appendChild(this.hitCanvas._canvas);\n    }\n  }\n  destroy() {\n    Util.releaseCanvas(this.getNativeCanvasElement(), this.getHitCanvas()._canvas);\n    return super.destroy();\n  }\n}\nLayer.prototype.nodeType = 'Layer';\n_registerNode(Layer);\nFactory.addGetterSetter(Layer, 'imageSmoothingEnabled', true);\nFactory.addGetterSetter(Layer, 'clearBeforeDraw', true);\nFactory.addGetterSetter(Layer, 'hitGraphEnabled', true, getBooleanValidator());","map":{"version":3,"names":["Util","Container","Node","Factory","SceneCanvas","HitCanvas","getBooleanValidator","shapes","_registerNode","HASH","BEFORE_DRAW","DRAW","INTERSECTION_OFFSETS","x","y","INTERSECTION_OFFSETS_LEN","length","Layer","constructor","config","canvas","hitCanvas","pixelRatio","_waitingForDraw","on","_checkVisibility","_setSmoothEnabled","createPNGStream","c","_canvas","getCanvas","getNativeCanvasElement","getHitCanvas","getContext","clear","bounds","setZIndex","index","stage","getStage","content","removeChild","children","insertBefore","appendChild","moveToTop","prototype","call","moveUp","moved","moveDown","moveToBottom","getLayer","remove","parentNode","_isInDocument","parent","setSize","width","height","_validateAdd","child","type","getType","throw","_toKonvaCanvas","getWidth","getHeight","undefined","visible","style","display","_context","imageSmoothingEnabled","setWidth","warn","setHeight","batchDraw","requestAnimFrame","draw","getIntersection","pos","isListening","isVisible","spiralSearchDistance","continueSearch","i","intersectionOffset","obj","_getIntersection","shape","antialiased","ratio","p","context","getImageData","Math","round","data","p3","colorKey","_rgbToHex","drawScene","can","top","bufferCanvas","layer","_fire","node","clearBeforeDraw","drawHit","enableHitGraph","hitGraphEnabled","disableHitGraph","setHitGraphEnabled","val","listening","getHitGraphEnabled","toggleHitCanvas","added","destroy","releaseCanvas","nodeType","addGetterSetter"],"sources":["C:/Users/lenovo pro/Documents/gncipl-6-week/Week-6_final_project/matty-project/client/node_modules/konva/lib/Layer.js"],"sourcesContent":["import { Util } from \"./Util.js\";\r\nimport { Container } from \"./Container.js\";\r\nimport { Node } from \"./Node.js\";\r\nimport { Factory } from \"./Factory.js\";\r\nimport { SceneCanvas, HitCanvas } from \"./Canvas.js\";\r\nimport { getBooleanValidator } from \"./Validators.js\";\r\nimport { shapes } from \"./Shape.js\";\r\nimport { _registerNode } from \"./Global.js\";\r\nconst HASH = '#', BEFORE_DRAW = 'beforeDraw', DRAW = 'draw', INTERSECTION_OFFSETS = [\r\n    { x: 0, y: 0 },\r\n    { x: -1, y: -1 },\r\n    { x: 1, y: -1 },\r\n    { x: 1, y: 1 },\r\n    { x: -1, y: 1 },\r\n], INTERSECTION_OFFSETS_LEN = INTERSECTION_OFFSETS.length;\r\nexport class Layer extends Container {\r\n    constructor(config) {\r\n        super(config);\r\n        this.canvas = new SceneCanvas();\r\n        this.hitCanvas = new HitCanvas({\r\n            pixelRatio: 1,\r\n        });\r\n        this._waitingForDraw = false;\r\n        this.on('visibleChange.konva', this._checkVisibility);\r\n        this._checkVisibility();\r\n        this.on('imageSmoothingEnabledChange.konva', this._setSmoothEnabled);\r\n        this._setSmoothEnabled();\r\n    }\r\n    createPNGStream() {\r\n        const c = this.canvas._canvas;\r\n        return c.createPNGStream();\r\n    }\r\n    getCanvas() {\r\n        return this.canvas;\r\n    }\r\n    getNativeCanvasElement() {\r\n        return this.canvas._canvas;\r\n    }\r\n    getHitCanvas() {\r\n        return this.hitCanvas;\r\n    }\r\n    getContext() {\r\n        return this.getCanvas().getContext();\r\n    }\r\n    clear(bounds) {\r\n        this.getContext().clear(bounds);\r\n        this.getHitCanvas().getContext().clear(bounds);\r\n        return this;\r\n    }\r\n    setZIndex(index) {\r\n        super.setZIndex(index);\r\n        const stage = this.getStage();\r\n        if (stage && stage.content) {\r\n            stage.content.removeChild(this.getNativeCanvasElement());\r\n            if (index < stage.children.length - 1) {\r\n                stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[index + 1].getCanvas()._canvas);\r\n            }\r\n            else {\r\n                stage.content.appendChild(this.getNativeCanvasElement());\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    moveToTop() {\r\n        Node.prototype.moveToTop.call(this);\r\n        const stage = this.getStage();\r\n        if (stage && stage.content) {\r\n            stage.content.removeChild(this.getNativeCanvasElement());\r\n            stage.content.appendChild(this.getNativeCanvasElement());\r\n        }\r\n        return true;\r\n    }\r\n    moveUp() {\r\n        const moved = Node.prototype.moveUp.call(this);\r\n        if (!moved) {\r\n            return false;\r\n        }\r\n        const stage = this.getStage();\r\n        if (!stage || !stage.content) {\r\n            return false;\r\n        }\r\n        stage.content.removeChild(this.getNativeCanvasElement());\r\n        if (this.index < stage.children.length - 1) {\r\n            stage.content.insertBefore(this.getNativeCanvasElement(), stage.children[this.index + 1].getCanvas()._canvas);\r\n        }\r\n        else {\r\n            stage.content.appendChild(this.getNativeCanvasElement());\r\n        }\r\n        return true;\r\n    }\r\n    moveDown() {\r\n        if (Node.prototype.moveDown.call(this)) {\r\n            const stage = this.getStage();\r\n            if (stage) {\r\n                const children = stage.children;\r\n                if (stage.content) {\r\n                    stage.content.removeChild(this.getNativeCanvasElement());\r\n                    stage.content.insertBefore(this.getNativeCanvasElement(), children[this.index + 1].getCanvas()._canvas);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    moveToBottom() {\r\n        if (Node.prototype.moveToBottom.call(this)) {\r\n            const stage = this.getStage();\r\n            if (stage) {\r\n                const children = stage.children;\r\n                if (stage.content) {\r\n                    stage.content.removeChild(this.getNativeCanvasElement());\r\n                    stage.content.insertBefore(this.getNativeCanvasElement(), children[1].getCanvas()._canvas);\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    getLayer() {\r\n        return this;\r\n    }\r\n    remove() {\r\n        const _canvas = this.getNativeCanvasElement();\r\n        Node.prototype.remove.call(this);\r\n        if (_canvas && _canvas.parentNode && Util._isInDocument(_canvas)) {\r\n            _canvas.parentNode.removeChild(_canvas);\r\n        }\r\n        return this;\r\n    }\r\n    getStage() {\r\n        return this.parent;\r\n    }\r\n    setSize({ width, height }) {\r\n        this.canvas.setSize(width, height);\r\n        this.hitCanvas.setSize(width, height);\r\n        this._setSmoothEnabled();\r\n        return this;\r\n    }\r\n    _validateAdd(child) {\r\n        const type = child.getType();\r\n        if (type !== 'Group' && type !== 'Shape') {\r\n            Util.throw('You may only add groups and shapes to a layer.');\r\n        }\r\n    }\r\n    _toKonvaCanvas(config) {\r\n        config = { ...config };\r\n        config.width = config.width || this.getWidth();\r\n        config.height = config.height || this.getHeight();\r\n        config.x = config.x !== undefined ? config.x : this.x();\r\n        config.y = config.y !== undefined ? config.y : this.y();\r\n        return Node.prototype._toKonvaCanvas.call(this, config);\r\n    }\r\n    _checkVisibility() {\r\n        const visible = this.visible();\r\n        if (visible) {\r\n            this.canvas._canvas.style.display = 'block';\r\n        }\r\n        else {\r\n            this.canvas._canvas.style.display = 'none';\r\n        }\r\n    }\r\n    _setSmoothEnabled() {\r\n        this.getContext()._context.imageSmoothingEnabled =\r\n            this.imageSmoothingEnabled();\r\n    }\r\n    getWidth() {\r\n        if (this.parent) {\r\n            return this.parent.width();\r\n        }\r\n    }\r\n    setWidth() {\r\n        Util.warn('Can not change width of layer. Use \"stage.width(value)\" function instead.');\r\n    }\r\n    getHeight() {\r\n        if (this.parent) {\r\n            return this.parent.height();\r\n        }\r\n    }\r\n    setHeight() {\r\n        Util.warn('Can not change height of layer. Use \"stage.height(value)\" function instead.');\r\n    }\r\n    batchDraw() {\r\n        if (!this._waitingForDraw) {\r\n            this._waitingForDraw = true;\r\n            Util.requestAnimFrame(() => {\r\n                this.draw();\r\n                this._waitingForDraw = false;\r\n            });\r\n        }\r\n        return this;\r\n    }\r\n    getIntersection(pos) {\r\n        if (!this.isListening() || !this.isVisible()) {\r\n            return null;\r\n        }\r\n        let spiralSearchDistance = 1;\r\n        let continueSearch = false;\r\n        while (true) {\r\n            for (let i = 0; i < INTERSECTION_OFFSETS_LEN; i++) {\r\n                const intersectionOffset = INTERSECTION_OFFSETS[i];\r\n                const obj = this._getIntersection({\r\n                    x: pos.x + intersectionOffset.x * spiralSearchDistance,\r\n                    y: pos.y + intersectionOffset.y * spiralSearchDistance,\r\n                });\r\n                const shape = obj.shape;\r\n                if (shape) {\r\n                    return shape;\r\n                }\r\n                continueSearch = !!obj.antialiased;\r\n                if (!obj.antialiased) {\r\n                    break;\r\n                }\r\n            }\r\n            if (continueSearch) {\r\n                spiralSearchDistance += 1;\r\n            }\r\n            else {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    _getIntersection(pos) {\r\n        const ratio = this.hitCanvas.pixelRatio;\r\n        const p = this.hitCanvas.context.getImageData(Math.round(pos.x * ratio), Math.round(pos.y * ratio), 1, 1).data;\r\n        const p3 = p[3];\r\n        if (p3 === 255) {\r\n            const colorKey = Util._rgbToHex(p[0], p[1], p[2]);\r\n            const shape = shapes[HASH + colorKey];\r\n            if (shape) {\r\n                return {\r\n                    shape: shape,\r\n                };\r\n            }\r\n            return {\r\n                antialiased: true,\r\n            };\r\n        }\r\n        else if (p3 > 0) {\r\n            return {\r\n                antialiased: true,\r\n            };\r\n        }\r\n        return {};\r\n    }\r\n    drawScene(can, top, bufferCanvas) {\r\n        const layer = this.getLayer(), canvas = can || (layer && layer.getCanvas());\r\n        this._fire(BEFORE_DRAW, {\r\n            node: this,\r\n        });\r\n        if (this.clearBeforeDraw()) {\r\n            canvas.getContext().clear();\r\n        }\r\n        Container.prototype.drawScene.call(this, canvas, top, bufferCanvas);\r\n        this._fire(DRAW, {\r\n            node: this,\r\n        });\r\n        return this;\r\n    }\r\n    drawHit(can, top) {\r\n        const layer = this.getLayer(), canvas = can || (layer && layer.hitCanvas);\r\n        if (layer && layer.clearBeforeDraw()) {\r\n            layer.getHitCanvas().getContext().clear();\r\n        }\r\n        Container.prototype.drawHit.call(this, canvas, top);\r\n        return this;\r\n    }\r\n    enableHitGraph() {\r\n        this.hitGraphEnabled(true);\r\n        return this;\r\n    }\r\n    disableHitGraph() {\r\n        this.hitGraphEnabled(false);\r\n        return this;\r\n    }\r\n    setHitGraphEnabled(val) {\r\n        Util.warn('hitGraphEnabled method is deprecated. Please use layer.listening() instead.');\r\n        this.listening(val);\r\n    }\r\n    getHitGraphEnabled(val) {\r\n        Util.warn('hitGraphEnabled method is deprecated. Please use layer.listening() instead.');\r\n        return this.listening();\r\n    }\r\n    toggleHitCanvas() {\r\n        if (!this.parent || !this.parent['content']) {\r\n            return;\r\n        }\r\n        const parent = this.parent;\r\n        const added = !!this.hitCanvas._canvas.parentNode;\r\n        if (added) {\r\n            parent.content.removeChild(this.hitCanvas._canvas);\r\n        }\r\n        else {\r\n            parent.content.appendChild(this.hitCanvas._canvas);\r\n        }\r\n    }\r\n    destroy() {\r\n        Util.releaseCanvas(this.getNativeCanvasElement(), this.getHitCanvas()._canvas);\r\n        return super.destroy();\r\n    }\r\n}\r\nLayer.prototype.nodeType = 'Layer';\r\n_registerNode(Layer);\r\nFactory.addGetterSetter(Layer, 'imageSmoothingEnabled', true);\r\nFactory.addGetterSetter(Layer, 'clearBeforeDraw', true);\r\nFactory.addGetterSetter(Layer, 'hitGraphEnabled', true, getBooleanValidator());\r\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,WAAW;AAChC,SAASC,SAAS,QAAQ,gBAAgB;AAC1C,SAASC,IAAI,QAAQ,WAAW;AAChC,SAASC,OAAO,QAAQ,cAAc;AACtC,SAASC,WAAW,EAAEC,SAAS,QAAQ,aAAa;AACpD,SAASC,mBAAmB,QAAQ,iBAAiB;AACrD,SAASC,MAAM,QAAQ,YAAY;AACnC,SAASC,aAAa,QAAQ,aAAa;AAC3C,MAAMC,IAAI,GAAG,GAAG;EAAEC,WAAW,GAAG,YAAY;EAAEC,IAAI,GAAG,MAAM;EAAEC,oBAAoB,GAAG,CAChF;IAAEC,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC,EACd;IAAED,CAAC,EAAE,CAAC,CAAC;IAAEC,CAAC,EAAE,CAAC;EAAE,CAAC,EAChB;IAAED,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE,CAAC;EAAE,CAAC,EACf;IAAED,CAAC,EAAE,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC,EACd;IAAED,CAAC,EAAE,CAAC,CAAC;IAAEC,CAAC,EAAE;EAAE,CAAC,CAClB;EAAEC,wBAAwB,GAAGH,oBAAoB,CAACI,MAAM;AACzD,OAAO,MAAMC,KAAK,SAAShB,SAAS,CAAC;EACjCiB,WAAWA,CAACC,MAAM,EAAE;IAChB,KAAK,CAACA,MAAM,CAAC;IACb,IAAI,CAACC,MAAM,GAAG,IAAIhB,WAAW,CAAC,CAAC;IAC/B,IAAI,CAACiB,SAAS,GAAG,IAAIhB,SAAS,CAAC;MAC3BiB,UAAU,EAAE;IAChB,CAAC,CAAC;IACF,IAAI,CAACC,eAAe,GAAG,KAAK;IAC5B,IAAI,CAACC,EAAE,CAAC,qBAAqB,EAAE,IAAI,CAACC,gBAAgB,CAAC;IACrD,IAAI,CAACA,gBAAgB,CAAC,CAAC;IACvB,IAAI,CAACD,EAAE,CAAC,mCAAmC,EAAE,IAAI,CAACE,iBAAiB,CAAC;IACpE,IAAI,CAACA,iBAAiB,CAAC,CAAC;EAC5B;EACAC,eAAeA,CAAA,EAAG;IACd,MAAMC,CAAC,GAAG,IAAI,CAACR,MAAM,CAACS,OAAO;IAC7B,OAAOD,CAAC,CAACD,eAAe,CAAC,CAAC;EAC9B;EACAG,SAASA,CAAA,EAAG;IACR,OAAO,IAAI,CAACV,MAAM;EACtB;EACAW,sBAAsBA,CAAA,EAAG;IACrB,OAAO,IAAI,CAACX,MAAM,CAACS,OAAO;EAC9B;EACAG,YAAYA,CAAA,EAAG;IACX,OAAO,IAAI,CAACX,SAAS;EACzB;EACAY,UAAUA,CAAA,EAAG;IACT,OAAO,IAAI,CAACH,SAAS,CAAC,CAAC,CAACG,UAAU,CAAC,CAAC;EACxC;EACAC,KAAKA,CAACC,MAAM,EAAE;IACV,IAAI,CAACF,UAAU,CAAC,CAAC,CAACC,KAAK,CAACC,MAAM,CAAC;IAC/B,IAAI,CAACH,YAAY,CAAC,CAAC,CAACC,UAAU,CAAC,CAAC,CAACC,KAAK,CAACC,MAAM,CAAC;IAC9C,OAAO,IAAI;EACf;EACAC,SAASA,CAACC,KAAK,EAAE;IACb,KAAK,CAACD,SAAS,CAACC,KAAK,CAAC;IACtB,MAAMC,KAAK,GAAG,IAAI,CAACC,QAAQ,CAAC,CAAC;IAC7B,IAAID,KAAK,IAAIA,KAAK,CAACE,OAAO,EAAE;MACxBF,KAAK,CAACE,OAAO,CAACC,WAAW,CAAC,IAAI,CAACV,sBAAsB,CAAC,CAAC,CAAC;MACxD,IAAIM,KAAK,GAAGC,KAAK,CAACI,QAAQ,CAAC1B,MAAM,GAAG,CAAC,EAAE;QACnCsB,KAAK,CAACE,OAAO,CAACG,YAAY,CAAC,IAAI,CAACZ,sBAAsB,CAAC,CAAC,EAAEO,KAAK,CAACI,QAAQ,CAACL,KAAK,GAAG,CAAC,CAAC,CAACP,SAAS,CAAC,CAAC,CAACD,OAAO,CAAC;MAC5G,CAAC,MACI;QACDS,KAAK,CAACE,OAAO,CAACI,WAAW,CAAC,IAAI,CAACb,sBAAsB,CAAC,CAAC,CAAC;MAC5D;IACJ;IACA,OAAO,IAAI;EACf;EACAc,SAASA,CAAA,EAAG;IACR3C,IAAI,CAAC4C,SAAS,CAACD,SAAS,CAACE,IAAI,CAAC,IAAI,CAAC;IACnC,MAAMT,KAAK,GAAG,IAAI,CAACC,QAAQ,CAAC,CAAC;IAC7B,IAAID,KAAK,IAAIA,KAAK,CAACE,OAAO,EAAE;MACxBF,KAAK,CAACE,OAAO,CAACC,WAAW,CAAC,IAAI,CAACV,sBAAsB,CAAC,CAAC,CAAC;MACxDO,KAAK,CAACE,OAAO,CAACI,WAAW,CAAC,IAAI,CAACb,sBAAsB,CAAC,CAAC,CAAC;IAC5D;IACA,OAAO,IAAI;EACf;EACAiB,MAAMA,CAAA,EAAG;IACL,MAAMC,KAAK,GAAG/C,IAAI,CAAC4C,SAAS,CAACE,MAAM,CAACD,IAAI,CAAC,IAAI,CAAC;IAC9C,IAAI,CAACE,KAAK,EAAE;MACR,OAAO,KAAK;IAChB;IACA,MAAMX,KAAK,GAAG,IAAI,CAACC,QAAQ,CAAC,CAAC;IAC7B,IAAI,CAACD,KAAK,IAAI,CAACA,KAAK,CAACE,OAAO,EAAE;MAC1B,OAAO,KAAK;IAChB;IACAF,KAAK,CAACE,OAAO,CAACC,WAAW,CAAC,IAAI,CAACV,sBAAsB,CAAC,CAAC,CAAC;IACxD,IAAI,IAAI,CAACM,KAAK,GAAGC,KAAK,CAACI,QAAQ,CAAC1B,MAAM,GAAG,CAAC,EAAE;MACxCsB,KAAK,CAACE,OAAO,CAACG,YAAY,CAAC,IAAI,CAACZ,sBAAsB,CAAC,CAAC,EAAEO,KAAK,CAACI,QAAQ,CAAC,IAAI,CAACL,KAAK,GAAG,CAAC,CAAC,CAACP,SAAS,CAAC,CAAC,CAACD,OAAO,CAAC;IACjH,CAAC,MACI;MACDS,KAAK,CAACE,OAAO,CAACI,WAAW,CAAC,IAAI,CAACb,sBAAsB,CAAC,CAAC,CAAC;IAC5D;IACA,OAAO,IAAI;EACf;EACAmB,QAAQA,CAAA,EAAG;IACP,IAAIhD,IAAI,CAAC4C,SAAS,CAACI,QAAQ,CAACH,IAAI,CAAC,IAAI,CAAC,EAAE;MACpC,MAAMT,KAAK,GAAG,IAAI,CAACC,QAAQ,CAAC,CAAC;MAC7B,IAAID,KAAK,EAAE;QACP,MAAMI,QAAQ,GAAGJ,KAAK,CAACI,QAAQ;QAC/B,IAAIJ,KAAK,CAACE,OAAO,EAAE;UACfF,KAAK,CAACE,OAAO,CAACC,WAAW,CAAC,IAAI,CAACV,sBAAsB,CAAC,CAAC,CAAC;UACxDO,KAAK,CAACE,OAAO,CAACG,YAAY,CAAC,IAAI,CAACZ,sBAAsB,CAAC,CAAC,EAAEW,QAAQ,CAAC,IAAI,CAACL,KAAK,GAAG,CAAC,CAAC,CAACP,SAAS,CAAC,CAAC,CAACD,OAAO,CAAC;QAC3G;MACJ;MACA,OAAO,IAAI;IACf;IACA,OAAO,KAAK;EAChB;EACAsB,YAAYA,CAAA,EAAG;IACX,IAAIjD,IAAI,CAAC4C,SAAS,CAACK,YAAY,CAACJ,IAAI,CAAC,IAAI,CAAC,EAAE;MACxC,MAAMT,KAAK,GAAG,IAAI,CAACC,QAAQ,CAAC,CAAC;MAC7B,IAAID,KAAK,EAAE;QACP,MAAMI,QAAQ,GAAGJ,KAAK,CAACI,QAAQ;QAC/B,IAAIJ,KAAK,CAACE,OAAO,EAAE;UACfF,KAAK,CAACE,OAAO,CAACC,WAAW,CAAC,IAAI,CAACV,sBAAsB,CAAC,CAAC,CAAC;UACxDO,KAAK,CAACE,OAAO,CAACG,YAAY,CAAC,IAAI,CAACZ,sBAAsB,CAAC,CAAC,EAAEW,QAAQ,CAAC,CAAC,CAAC,CAACZ,SAAS,CAAC,CAAC,CAACD,OAAO,CAAC;QAC9F;MACJ;MACA,OAAO,IAAI;IACf;IACA,OAAO,KAAK;EAChB;EACAuB,QAAQA,CAAA,EAAG;IACP,OAAO,IAAI;EACf;EACAC,MAAMA,CAAA,EAAG;IACL,MAAMxB,OAAO,GAAG,IAAI,CAACE,sBAAsB,CAAC,CAAC;IAC7C7B,IAAI,CAAC4C,SAAS,CAACO,MAAM,CAACN,IAAI,CAAC,IAAI,CAAC;IAChC,IAAIlB,OAAO,IAAIA,OAAO,CAACyB,UAAU,IAAItD,IAAI,CAACuD,aAAa,CAAC1B,OAAO,CAAC,EAAE;MAC9DA,OAAO,CAACyB,UAAU,CAACb,WAAW,CAACZ,OAAO,CAAC;IAC3C;IACA,OAAO,IAAI;EACf;EACAU,QAAQA,CAAA,EAAG;IACP,OAAO,IAAI,CAACiB,MAAM;EACtB;EACAC,OAAOA,CAAC;IAAEC,KAAK;IAAEC;EAAO,CAAC,EAAE;IACvB,IAAI,CAACvC,MAAM,CAACqC,OAAO,CAACC,KAAK,EAAEC,MAAM,CAAC;IAClC,IAAI,CAACtC,SAAS,CAACoC,OAAO,CAACC,KAAK,EAAEC,MAAM,CAAC;IACrC,IAAI,CAACjC,iBAAiB,CAAC,CAAC;IACxB,OAAO,IAAI;EACf;EACAkC,YAAYA,CAACC,KAAK,EAAE;IAChB,MAAMC,IAAI,GAAGD,KAAK,CAACE,OAAO,CAAC,CAAC;IAC5B,IAAID,IAAI,KAAK,OAAO,IAAIA,IAAI,KAAK,OAAO,EAAE;MACtC9D,IAAI,CAACgE,KAAK,CAAC,gDAAgD,CAAC;IAChE;EACJ;EACAC,cAAcA,CAAC9C,MAAM,EAAE;IACnBA,MAAM,GAAG;MAAE,GAAGA;IAAO,CAAC;IACtBA,MAAM,CAACuC,KAAK,GAAGvC,MAAM,CAACuC,KAAK,IAAI,IAAI,CAACQ,QAAQ,CAAC,CAAC;IAC9C/C,MAAM,CAACwC,MAAM,GAAGxC,MAAM,CAACwC,MAAM,IAAI,IAAI,CAACQ,SAAS,CAAC,CAAC;IACjDhD,MAAM,CAACN,CAAC,GAAGM,MAAM,CAACN,CAAC,KAAKuD,SAAS,GAAGjD,MAAM,CAACN,CAAC,GAAG,IAAI,CAACA,CAAC,CAAC,CAAC;IACvDM,MAAM,CAACL,CAAC,GAAGK,MAAM,CAACL,CAAC,KAAKsD,SAAS,GAAGjD,MAAM,CAACL,CAAC,GAAG,IAAI,CAACA,CAAC,CAAC,CAAC;IACvD,OAAOZ,IAAI,CAAC4C,SAAS,CAACmB,cAAc,CAAClB,IAAI,CAAC,IAAI,EAAE5B,MAAM,CAAC;EAC3D;EACAM,gBAAgBA,CAAA,EAAG;IACf,MAAM4C,OAAO,GAAG,IAAI,CAACA,OAAO,CAAC,CAAC;IAC9B,IAAIA,OAAO,EAAE;MACT,IAAI,CAACjD,MAAM,CAACS,OAAO,CAACyC,KAAK,CAACC,OAAO,GAAG,OAAO;IAC/C,CAAC,MACI;MACD,IAAI,CAACnD,MAAM,CAACS,OAAO,CAACyC,KAAK,CAACC,OAAO,GAAG,MAAM;IAC9C;EACJ;EACA7C,iBAAiBA,CAAA,EAAG;IAChB,IAAI,CAACO,UAAU,CAAC,CAAC,CAACuC,QAAQ,CAACC,qBAAqB,GAC5C,IAAI,CAACA,qBAAqB,CAAC,CAAC;EACpC;EACAP,QAAQA,CAAA,EAAG;IACP,IAAI,IAAI,CAACV,MAAM,EAAE;MACb,OAAO,IAAI,CAACA,MAAM,CAACE,KAAK,CAAC,CAAC;IAC9B;EACJ;EACAgB,QAAQA,CAAA,EAAG;IACP1E,IAAI,CAAC2E,IAAI,CAAC,2EAA2E,CAAC;EAC1F;EACAR,SAASA,CAAA,EAAG;IACR,IAAI,IAAI,CAACX,MAAM,EAAE;MACb,OAAO,IAAI,CAACA,MAAM,CAACG,MAAM,CAAC,CAAC;IAC/B;EACJ;EACAiB,SAASA,CAAA,EAAG;IACR5E,IAAI,CAAC2E,IAAI,CAAC,6EAA6E,CAAC;EAC5F;EACAE,SAASA,CAAA,EAAG;IACR,IAAI,CAAC,IAAI,CAACtD,eAAe,EAAE;MACvB,IAAI,CAACA,eAAe,GAAG,IAAI;MAC3BvB,IAAI,CAAC8E,gBAAgB,CAAC,MAAM;QACxB,IAAI,CAACC,IAAI,CAAC,CAAC;QACX,IAAI,CAACxD,eAAe,GAAG,KAAK;MAChC,CAAC,CAAC;IACN;IACA,OAAO,IAAI;EACf;EACAyD,eAAeA,CAACC,GAAG,EAAE;IACjB,IAAI,CAAC,IAAI,CAACC,WAAW,CAAC,CAAC,IAAI,CAAC,IAAI,CAACC,SAAS,CAAC,CAAC,EAAE;MAC1C,OAAO,IAAI;IACf;IACA,IAAIC,oBAAoB,GAAG,CAAC;IAC5B,IAAIC,cAAc,GAAG,KAAK;IAC1B,OAAO,IAAI,EAAE;MACT,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGvE,wBAAwB,EAAEuE,CAAC,EAAE,EAAE;QAC/C,MAAMC,kBAAkB,GAAG3E,oBAAoB,CAAC0E,CAAC,CAAC;QAClD,MAAME,GAAG,GAAG,IAAI,CAACC,gBAAgB,CAAC;UAC9B5E,CAAC,EAAEoE,GAAG,CAACpE,CAAC,GAAG0E,kBAAkB,CAAC1E,CAAC,GAAGuE,oBAAoB;UACtDtE,CAAC,EAAEmE,GAAG,CAACnE,CAAC,GAAGyE,kBAAkB,CAACzE,CAAC,GAAGsE;QACtC,CAAC,CAAC;QACF,MAAMM,KAAK,GAAGF,GAAG,CAACE,KAAK;QACvB,IAAIA,KAAK,EAAE;UACP,OAAOA,KAAK;QAChB;QACAL,cAAc,GAAG,CAAC,CAACG,GAAG,CAACG,WAAW;QAClC,IAAI,CAACH,GAAG,CAACG,WAAW,EAAE;UAClB;QACJ;MACJ;MACA,IAAIN,cAAc,EAAE;QAChBD,oBAAoB,IAAI,CAAC;MAC7B,CAAC,MACI;QACD,OAAO,IAAI;MACf;IACJ;EACJ;EACAK,gBAAgBA,CAACR,GAAG,EAAE;IAClB,MAAMW,KAAK,GAAG,IAAI,CAACvE,SAAS,CAACC,UAAU;IACvC,MAAMuE,CAAC,GAAG,IAAI,CAACxE,SAAS,CAACyE,OAAO,CAACC,YAAY,CAACC,IAAI,CAACC,KAAK,CAAChB,GAAG,CAACpE,CAAC,GAAG+E,KAAK,CAAC,EAAEI,IAAI,CAACC,KAAK,CAAChB,GAAG,CAACnE,CAAC,GAAG8E,KAAK,CAAC,EAAE,CAAC,EAAE,CAAC,CAAC,CAACM,IAAI;IAC9G,MAAMC,EAAE,GAAGN,CAAC,CAAC,CAAC,CAAC;IACf,IAAIM,EAAE,KAAK,GAAG,EAAE;MACZ,MAAMC,QAAQ,GAAGpG,IAAI,CAACqG,SAAS,CAACR,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,EAAEA,CAAC,CAAC,CAAC,CAAC,CAAC;MACjD,MAAMH,KAAK,GAAGnF,MAAM,CAACE,IAAI,GAAG2F,QAAQ,CAAC;MACrC,IAAIV,KAAK,EAAE;QACP,OAAO;UACHA,KAAK,EAAEA;QACX,CAAC;MACL;MACA,OAAO;QACHC,WAAW,EAAE;MACjB,CAAC;IACL,CAAC,MACI,IAAIQ,EAAE,GAAG,CAAC,EAAE;MACb,OAAO;QACHR,WAAW,EAAE;MACjB,CAAC;IACL;IACA,OAAO,CAAC,CAAC;EACb;EACAW,SAASA,CAACC,GAAG,EAAEC,GAAG,EAAEC,YAAY,EAAE;IAC9B,MAAMC,KAAK,GAAG,IAAI,CAACtD,QAAQ,CAAC,CAAC;MAAEhC,MAAM,GAAGmF,GAAG,IAAKG,KAAK,IAAIA,KAAK,CAAC5E,SAAS,CAAC,CAAE;IAC3E,IAAI,CAAC6E,KAAK,CAACjG,WAAW,EAAE;MACpBkG,IAAI,EAAE;IACV,CAAC,CAAC;IACF,IAAI,IAAI,CAACC,eAAe,CAAC,CAAC,EAAE;MACxBzF,MAAM,CAACa,UAAU,CAAC,CAAC,CAACC,KAAK,CAAC,CAAC;IAC/B;IACAjC,SAAS,CAAC6C,SAAS,CAACwD,SAAS,CAACvD,IAAI,CAAC,IAAI,EAAE3B,MAAM,EAAEoF,GAAG,EAAEC,YAAY,CAAC;IACnE,IAAI,CAACE,KAAK,CAAChG,IAAI,EAAE;MACbiG,IAAI,EAAE;IACV,CAAC,CAAC;IACF,OAAO,IAAI;EACf;EACAE,OAAOA,CAACP,GAAG,EAAEC,GAAG,EAAE;IACd,MAAME,KAAK,GAAG,IAAI,CAACtD,QAAQ,CAAC,CAAC;MAAEhC,MAAM,GAAGmF,GAAG,IAAKG,KAAK,IAAIA,KAAK,CAACrF,SAAU;IACzE,IAAIqF,KAAK,IAAIA,KAAK,CAACG,eAAe,CAAC,CAAC,EAAE;MAClCH,KAAK,CAAC1E,YAAY,CAAC,CAAC,CAACC,UAAU,CAAC,CAAC,CAACC,KAAK,CAAC,CAAC;IAC7C;IACAjC,SAAS,CAAC6C,SAAS,CAACgE,OAAO,CAAC/D,IAAI,CAAC,IAAI,EAAE3B,MAAM,EAAEoF,GAAG,CAAC;IACnD,OAAO,IAAI;EACf;EACAO,cAAcA,CAAA,EAAG;IACb,IAAI,CAACC,eAAe,CAAC,IAAI,CAAC;IAC1B,OAAO,IAAI;EACf;EACAC,eAAeA,CAAA,EAAG;IACd,IAAI,CAACD,eAAe,CAAC,KAAK,CAAC;IAC3B,OAAO,IAAI;EACf;EACAE,kBAAkBA,CAACC,GAAG,EAAE;IACpBnH,IAAI,CAAC2E,IAAI,CAAC,6EAA6E,CAAC;IACxF,IAAI,CAACyC,SAAS,CAACD,GAAG,CAAC;EACvB;EACAE,kBAAkBA,CAACF,GAAG,EAAE;IACpBnH,IAAI,CAAC2E,IAAI,CAAC,6EAA6E,CAAC;IACxF,OAAO,IAAI,CAACyC,SAAS,CAAC,CAAC;EAC3B;EACAE,eAAeA,CAAA,EAAG;IACd,IAAI,CAAC,IAAI,CAAC9D,MAAM,IAAI,CAAC,IAAI,CAACA,MAAM,CAAC,SAAS,CAAC,EAAE;MACzC;IACJ;IACA,MAAMA,MAAM,GAAG,IAAI,CAACA,MAAM;IAC1B,MAAM+D,KAAK,GAAG,CAAC,CAAC,IAAI,CAAClG,SAAS,CAACQ,OAAO,CAACyB,UAAU;IACjD,IAAIiE,KAAK,EAAE;MACP/D,MAAM,CAAChB,OAAO,CAACC,WAAW,CAAC,IAAI,CAACpB,SAAS,CAACQ,OAAO,CAAC;IACtD,CAAC,MACI;MACD2B,MAAM,CAAChB,OAAO,CAACI,WAAW,CAAC,IAAI,CAACvB,SAAS,CAACQ,OAAO,CAAC;IACtD;EACJ;EACA2F,OAAOA,CAAA,EAAG;IACNxH,IAAI,CAACyH,aAAa,CAAC,IAAI,CAAC1F,sBAAsB,CAAC,CAAC,EAAE,IAAI,CAACC,YAAY,CAAC,CAAC,CAACH,OAAO,CAAC;IAC9E,OAAO,KAAK,CAAC2F,OAAO,CAAC,CAAC;EAC1B;AACJ;AACAvG,KAAK,CAAC6B,SAAS,CAAC4E,QAAQ,GAAG,OAAO;AAClClH,aAAa,CAACS,KAAK,CAAC;AACpBd,OAAO,CAACwH,eAAe,CAAC1G,KAAK,EAAE,uBAAuB,EAAE,IAAI,CAAC;AAC7Dd,OAAO,CAACwH,eAAe,CAAC1G,KAAK,EAAE,iBAAiB,EAAE,IAAI,CAAC;AACvDd,OAAO,CAACwH,eAAe,CAAC1G,KAAK,EAAE,iBAAiB,EAAE,IAAI,EAAEX,mBAAmB,CAAC,CAAC,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}