{"ast":null,"code":"import { Util } from \"./Util.js\";\nimport { Konva } from \"./Global.js\";\nfunction simplifyArray(arr) {\n  const retArr = [],\n    len = arr.length,\n    util = Util;\n  for (let n = 0; n < len; n++) {\n    let val = arr[n];\n    if (util._isNumber(val)) {\n      val = Math.round(val * 1000) / 1000;\n    } else if (!util._isString(val)) {\n      val = val + '';\n    }\n    retArr.push(val);\n  }\n  return retArr;\n}\nconst COMMA = ',',\n  OPEN_PAREN = '(',\n  CLOSE_PAREN = ')',\n  OPEN_PAREN_BRACKET = '([',\n  CLOSE_BRACKET_PAREN = '])',\n  SEMICOLON = ';',\n  DOUBLE_PAREN = '()',\n  EQUALS = '=',\n  CONTEXT_METHODS = ['arc', 'arcTo', 'beginPath', 'bezierCurveTo', 'clearRect', 'clip', 'closePath', 'createLinearGradient', 'createPattern', 'createRadialGradient', 'drawImage', 'ellipse', 'fill', 'fillText', 'getImageData', 'createImageData', 'lineTo', 'moveTo', 'putImageData', 'quadraticCurveTo', 'rect', 'roundRect', 'restore', 'rotate', 'save', 'scale', 'setLineDash', 'setTransform', 'stroke', 'strokeText', 'transform', 'translate'];\nconst CONTEXT_PROPERTIES = ['fillStyle', 'strokeStyle', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'letterSpacing', 'lineCap', 'lineDashOffset', 'lineJoin', 'lineWidth', 'miterLimit', 'direction', 'font', 'textAlign', 'textBaseline', 'globalAlpha', 'globalCompositeOperation', 'imageSmoothingEnabled', 'filter'];\nconst traceArrMax = 100;\nlet _cssFiltersSupported = null;\nexport function isCSSFiltersSupported() {\n  if (_cssFiltersSupported !== null) {\n    return _cssFiltersSupported;\n  }\n  try {\n    const canvas = Util.createCanvasElement();\n    const ctx = canvas.getContext('2d');\n    if (!ctx) {\n      _cssFiltersSupported = false;\n      return false;\n    }\n    return !!ctx && 'filter' in ctx;\n  } catch (e) {\n    _cssFiltersSupported = false;\n    return false;\n  }\n}\nexport class Context {\n  constructor(canvas) {\n    this.canvas = canvas;\n    if (Konva.enableTrace) {\n      this.traceArr = [];\n      this._enableTrace();\n    }\n  }\n  fillShape(shape) {\n    if (shape.fillEnabled()) {\n      this._fill(shape);\n    }\n  }\n  _fill(shape) {}\n  strokeShape(shape) {\n    if (shape.hasStroke()) {\n      this._stroke(shape);\n    }\n  }\n  _stroke(shape) {}\n  fillStrokeShape(shape) {\n    if (shape.attrs.fillAfterStrokeEnabled) {\n      this.strokeShape(shape);\n      this.fillShape(shape);\n    } else {\n      this.fillShape(shape);\n      this.strokeShape(shape);\n    }\n  }\n  getTrace(relaxed, rounded) {\n    let traceArr = this.traceArr,\n      len = traceArr.length,\n      str = '',\n      n,\n      trace,\n      method,\n      args;\n    for (n = 0; n < len; n++) {\n      trace = traceArr[n];\n      method = trace.method;\n      if (method) {\n        args = trace.args;\n        str += method;\n        if (relaxed) {\n          str += DOUBLE_PAREN;\n        } else {\n          if (Util._isArray(args[0])) {\n            str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;\n          } else {\n            if (rounded) {\n              args = args.map(a => typeof a === 'number' ? Math.floor(a) : a);\n            }\n            str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;\n          }\n        }\n      } else {\n        str += trace.property;\n        if (!relaxed) {\n          str += EQUALS + trace.val;\n        }\n      }\n      str += SEMICOLON;\n    }\n    return str;\n  }\n  clearTrace() {\n    this.traceArr = [];\n  }\n  _trace(str) {\n    let traceArr = this.traceArr,\n      len;\n    traceArr.push(str);\n    len = traceArr.length;\n    if (len >= traceArrMax) {\n      traceArr.shift();\n    }\n  }\n  reset() {\n    const pixelRatio = this.getCanvas().getPixelRatio();\n    this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);\n  }\n  getCanvas() {\n    return this.canvas;\n  }\n  clear(bounds) {\n    const canvas = this.getCanvas();\n    if (bounds) {\n      this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);\n    } else {\n      this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);\n    }\n  }\n  _applyLineCap(shape) {\n    const lineCap = shape.attrs.lineCap;\n    if (lineCap) {\n      this.setAttr('lineCap', lineCap);\n    }\n  }\n  _applyOpacity(shape) {\n    const absOpacity = shape.getAbsoluteOpacity();\n    if (absOpacity !== 1) {\n      this.setAttr('globalAlpha', absOpacity);\n    }\n  }\n  _applyLineJoin(shape) {\n    const lineJoin = shape.attrs.lineJoin;\n    if (lineJoin) {\n      this.setAttr('lineJoin', lineJoin);\n    }\n  }\n  _applyMiterLimit(shape) {\n    const miterLimit = shape.attrs.miterLimit;\n    if (miterLimit != null) {\n      this.setAttr('miterLimit', miterLimit);\n    }\n  }\n  setAttr(attr, val) {\n    this._context[attr] = val;\n  }\n  arc(x, y, radius, startAngle, endAngle, counterClockwise) {\n    this._context.arc(x, y, radius, startAngle, endAngle, counterClockwise);\n  }\n  arcTo(x1, y1, x2, y2, radius) {\n    this._context.arcTo(x1, y1, x2, y2, radius);\n  }\n  beginPath() {\n    this._context.beginPath();\n  }\n  bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\n    this._context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n  }\n  clearRect(x, y, width, height) {\n    this._context.clearRect(x, y, width, height);\n  }\n  clip() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    this._context.clip.apply(this._context, args);\n  }\n  closePath() {\n    this._context.closePath();\n  }\n  createImageData(width, height) {\n    const a = arguments;\n    if (a.length === 2) {\n      return this._context.createImageData(width, height);\n    } else if (a.length === 1) {\n      return this._context.createImageData(width);\n    }\n  }\n  createLinearGradient(x0, y0, x1, y1) {\n    return this._context.createLinearGradient(x0, y0, x1, y1);\n  }\n  createPattern(image, repetition) {\n    return this._context.createPattern(image, repetition);\n  }\n  createRadialGradient(x0, y0, r0, x1, y1, r1) {\n    return this._context.createRadialGradient(x0, y0, r0, x1, y1, r1);\n  }\n  drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {\n    const a = arguments,\n      _context = this._context;\n    if (a.length === 3) {\n      _context.drawImage(image, sx, sy);\n    } else if (a.length === 5) {\n      _context.drawImage(image, sx, sy, sWidth, sHeight);\n    } else if (a.length === 9) {\n      _context.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\n    }\n  }\n  ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise) {\n    this._context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise);\n  }\n  isPointInPath(x, y, path, fillRule) {\n    if (path) {\n      return this._context.isPointInPath(path, x, y, fillRule);\n    }\n    return this._context.isPointInPath(x, y, fillRule);\n  }\n  fill() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n    this._context.fill.apply(this._context, args);\n  }\n  fillRect(x, y, width, height) {\n    this._context.fillRect(x, y, width, height);\n  }\n  strokeRect(x, y, width, height) {\n    this._context.strokeRect(x, y, width, height);\n  }\n  fillText(text, x, y, maxWidth) {\n    if (maxWidth) {\n      this._context.fillText(text, x, y, maxWidth);\n    } else {\n      this._context.fillText(text, x, y);\n    }\n  }\n  measureText(text) {\n    return this._context.measureText(text);\n  }\n  getImageData(sx, sy, sw, sh) {\n    return this._context.getImageData(sx, sy, sw, sh);\n  }\n  lineTo(x, y) {\n    this._context.lineTo(x, y);\n  }\n  moveTo(x, y) {\n    this._context.moveTo(x, y);\n  }\n  rect(x, y, width, height) {\n    this._context.rect(x, y, width, height);\n  }\n  roundRect(x, y, width, height, radii) {\n    this._context.roundRect(x, y, width, height, radii);\n  }\n  putImageData(imageData, dx, dy) {\n    this._context.putImageData(imageData, dx, dy);\n  }\n  quadraticCurveTo(cpx, cpy, x, y) {\n    this._context.quadraticCurveTo(cpx, cpy, x, y);\n  }\n  restore() {\n    this._context.restore();\n  }\n  rotate(angle) {\n    this._context.rotate(angle);\n  }\n  save() {\n    this._context.save();\n  }\n  scale(x, y) {\n    this._context.scale(x, y);\n  }\n  setLineDash(segments) {\n    if (this._context.setLineDash) {\n      this._context.setLineDash(segments);\n    } else if ('mozDash' in this._context) {\n      this._context['mozDash'] = segments;\n    } else if ('webkitLineDash' in this._context) {\n      this._context['webkitLineDash'] = segments;\n    }\n  }\n  getLineDash() {\n    return this._context.getLineDash();\n  }\n  setTransform(a, b, c, d, e, f) {\n    this._context.setTransform(a, b, c, d, e, f);\n  }\n  stroke(path2d) {\n    if (path2d) {\n      this._context.stroke(path2d);\n    } else {\n      this._context.stroke();\n    }\n  }\n  strokeText(text, x, y, maxWidth) {\n    this._context.strokeText(text, x, y, maxWidth);\n  }\n  transform(a, b, c, d, e, f) {\n    this._context.transform(a, b, c, d, e, f);\n  }\n  translate(x, y) {\n    this._context.translate(x, y);\n  }\n  _enableTrace() {\n    let that = this,\n      len = CONTEXT_METHODS.length,\n      origSetter = this.setAttr,\n      n,\n      args;\n    const func = function (methodName) {\n      let origMethod = that[methodName],\n        ret;\n      that[methodName] = function () {\n        args = simplifyArray(Array.prototype.slice.call(arguments, 0));\n        ret = origMethod.apply(that, arguments);\n        that._trace({\n          method: methodName,\n          args: args\n        });\n        return ret;\n      };\n    };\n    for (n = 0; n < len; n++) {\n      func(CONTEXT_METHODS[n]);\n    }\n    that.setAttr = function () {\n      origSetter.apply(that, arguments);\n      const prop = arguments[0];\n      let val = arguments[1];\n      if (prop === 'shadowOffsetX' || prop === 'shadowOffsetY' || prop === 'shadowBlur') {\n        val = val / this.canvas.getPixelRatio();\n      }\n      that._trace({\n        property: prop,\n        val: val\n      });\n    };\n  }\n  _applyGlobalCompositeOperation(node) {\n    const op = node.attrs.globalCompositeOperation;\n    const def = !op || op === 'source-over';\n    if (!def) {\n      this.setAttr('globalCompositeOperation', op);\n    }\n  }\n}\nCONTEXT_PROPERTIES.forEach(function (prop) {\n  Object.defineProperty(Context.prototype, prop, {\n    get() {\n      return this._context[prop];\n    },\n    set(val) {\n      this._context[prop] = val;\n    }\n  });\n});\nexport class SceneContext extends Context {\n  constructor(canvas) {\n    let {\n      willReadFrequently = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super(canvas);\n    this._context = canvas._canvas.getContext('2d', {\n      willReadFrequently\n    });\n  }\n  _fillColor(shape) {\n    const fill = shape.fill();\n    this.setAttr('fillStyle', fill);\n    shape._fillFunc(this);\n  }\n  _fillPattern(shape) {\n    this.setAttr('fillStyle', shape._getFillPattern());\n    shape._fillFunc(this);\n  }\n  _fillLinearGradient(shape) {\n    const grd = shape._getLinearGradient();\n    if (grd) {\n      this.setAttr('fillStyle', grd);\n      shape._fillFunc(this);\n    }\n  }\n  _fillRadialGradient(shape) {\n    const grd = shape._getRadialGradient();\n    if (grd) {\n      this.setAttr('fillStyle', grd);\n      shape._fillFunc(this);\n    }\n  }\n  _fill(shape) {\n    const hasColor = shape.fill(),\n      fillPriority = shape.getFillPriority();\n    if (hasColor && fillPriority === 'color') {\n      this._fillColor(shape);\n      return;\n    }\n    const hasPattern = shape.getFillPatternImage();\n    if (hasPattern && fillPriority === 'pattern') {\n      this._fillPattern(shape);\n      return;\n    }\n    const hasLinearGradient = shape.getFillLinearGradientColorStops();\n    if (hasLinearGradient && fillPriority === 'linear-gradient') {\n      this._fillLinearGradient(shape);\n      return;\n    }\n    const hasRadialGradient = shape.getFillRadialGradientColorStops();\n    if (hasRadialGradient && fillPriority === 'radial-gradient') {\n      this._fillRadialGradient(shape);\n      return;\n    }\n    if (hasColor) {\n      this._fillColor(shape);\n    } else if (hasPattern) {\n      this._fillPattern(shape);\n    } else if (hasLinearGradient) {\n      this._fillLinearGradient(shape);\n    } else if (hasRadialGradient) {\n      this._fillRadialGradient(shape);\n    }\n  }\n  _strokeLinearGradient(shape) {\n    const start = shape.getStrokeLinearGradientStartPoint(),\n      end = shape.getStrokeLinearGradientEndPoint(),\n      colorStops = shape.getStrokeLinearGradientColorStops(),\n      grd = this.createLinearGradient(start.x, start.y, end.x, end.y);\n    if (colorStops) {\n      for (let n = 0; n < colorStops.length; n += 2) {\n        grd.addColorStop(colorStops[n], colorStops[n + 1]);\n      }\n      this.setAttr('strokeStyle', grd);\n    }\n  }\n  _stroke(shape) {\n    const dash = shape.dash(),\n      strokeScaleEnabled = shape.getStrokeScaleEnabled();\n    if (shape.hasStroke()) {\n      if (!strokeScaleEnabled) {\n        this.save();\n        const pixelRatio = this.getCanvas().getPixelRatio();\n        this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n      }\n      this._applyLineCap(shape);\n      if (dash && shape.dashEnabled()) {\n        this.setLineDash(dash);\n        this.setAttr('lineDashOffset', shape.dashOffset());\n      }\n      this.setAttr('lineWidth', shape.strokeWidth());\n      if (!shape.getShadowForStrokeEnabled()) {\n        this.setAttr('shadowColor', 'rgba(0,0,0,0)');\n      }\n      const hasLinearGradient = shape.getStrokeLinearGradientColorStops();\n      if (hasLinearGradient) {\n        this._strokeLinearGradient(shape);\n      } else {\n        this.setAttr('strokeStyle', shape.stroke());\n      }\n      shape._strokeFunc(this);\n      if (!strokeScaleEnabled) {\n        this.restore();\n      }\n    }\n  }\n  _applyShadow(shape) {\n    var _a, _b, _c;\n    const color = (_a = shape.getShadowRGBA()) !== null && _a !== void 0 ? _a : 'black',\n      blur = (_b = shape.getShadowBlur()) !== null && _b !== void 0 ? _b : 5,\n      offset = (_c = shape.getShadowOffset()) !== null && _c !== void 0 ? _c : {\n        x: 0,\n        y: 0\n      },\n      scale = shape.getAbsoluteScale(),\n      ratio = this.canvas.getPixelRatio(),\n      scaleX = scale.x * ratio,\n      scaleY = scale.y * ratio;\n    this.setAttr('shadowColor', color);\n    this.setAttr('shadowBlur', blur * Math.min(Math.abs(scaleX), Math.abs(scaleY)));\n    this.setAttr('shadowOffsetX', offset.x * scaleX);\n    this.setAttr('shadowOffsetY', offset.y * scaleY);\n  }\n}\nexport class HitContext extends Context {\n  constructor(canvas) {\n    super(canvas);\n    this._context = canvas._canvas.getContext('2d', {\n      willReadFrequently: true\n    });\n  }\n  _fill(shape) {\n    this.save();\n    this.setAttr('fillStyle', shape.colorKey);\n    shape._fillFuncHit(this);\n    this.restore();\n  }\n  strokeShape(shape) {\n    if (shape.hasHitStroke()) {\n      this._stroke(shape);\n    }\n  }\n  _stroke(shape) {\n    if (shape.hasHitStroke()) {\n      const strokeScaleEnabled = shape.getStrokeScaleEnabled();\n      if (!strokeScaleEnabled) {\n        this.save();\n        const pixelRatio = this.getCanvas().getPixelRatio();\n        this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\n      }\n      this._applyLineCap(shape);\n      const hitStrokeWidth = shape.hitStrokeWidth();\n      const strokeWidth = hitStrokeWidth === 'auto' ? shape.strokeWidth() : hitStrokeWidth;\n      this.setAttr('lineWidth', strokeWidth);\n      this.setAttr('strokeStyle', shape.colorKey);\n      shape._strokeFuncHit(this);\n      if (!strokeScaleEnabled) {\n        this.restore();\n      }\n    }\n  }\n}","map":{"version":3,"names":["Util","Konva","simplifyArray","arr","retArr","len","length","util","n","val","_isNumber","Math","round","_isString","push","COMMA","OPEN_PAREN","CLOSE_PAREN","OPEN_PAREN_BRACKET","CLOSE_BRACKET_PAREN","SEMICOLON","DOUBLE_PAREN","EQUALS","CONTEXT_METHODS","CONTEXT_PROPERTIES","traceArrMax","_cssFiltersSupported","isCSSFiltersSupported","canvas","createCanvasElement","ctx","getContext","e","Context","constructor","enableTrace","traceArr","_enableTrace","fillShape","shape","fillEnabled","_fill","strokeShape","hasStroke","_stroke","fillStrokeShape","attrs","fillAfterStrokeEnabled","getTrace","relaxed","rounded","str","trace","method","args","_isArray","join","map","a","floor","property","clearTrace","_trace","shift","reset","pixelRatio","getCanvas","getPixelRatio","setTransform","clear","bounds","clearRect","x","y","width","height","getWidth","getHeight","_applyLineCap","lineCap","setAttr","_applyOpacity","absOpacity","getAbsoluteOpacity","_applyLineJoin","lineJoin","_applyMiterLimit","miterLimit","attr","_context","arc","radius","startAngle","endAngle","counterClockwise","arcTo","x1","y1","x2","y2","beginPath","bezierCurveTo","cp1x","cp1y","cp2x","cp2y","clip","_len","arguments","Array","_key","apply","closePath","createImageData","createLinearGradient","x0","y0","createPattern","image","repetition","createRadialGradient","r0","r1","drawImage","sx","sy","sWidth","sHeight","dx","dy","dWidth","dHeight","ellipse","radiusX","radiusY","rotation","counterclockwise","isPointInPath","path","fillRule","fill","_len2","_key2","fillRect","strokeRect","fillText","text","maxWidth","measureText","getImageData","sw","sh","lineTo","moveTo","rect","roundRect","radii","putImageData","imageData","quadraticCurveTo","cpx","cpy","restore","rotate","angle","save","scale","setLineDash","segments","getLineDash","b","c","d","f","stroke","path2d","strokeText","transform","translate","that","origSetter","func","methodName","origMethod","ret","prototype","slice","call","prop","_applyGlobalCompositeOperation","node","op","globalCompositeOperation","def","forEach","Object","defineProperty","get","set","SceneContext","willReadFrequently","undefined","_canvas","_fillColor","_fillFunc","_fillPattern","_getFillPattern","_fillLinearGradient","grd","_getLinearGradient","_fillRadialGradient","_getRadialGradient","hasColor","fillPriority","getFillPriority","hasPattern","getFillPatternImage","hasLinearGradient","getFillLinearGradientColorStops","hasRadialGradient","getFillRadialGradientColorStops","_strokeLinearGradient","start","getStrokeLinearGradientStartPoint","end","getStrokeLinearGradientEndPoint","colorStops","getStrokeLinearGradientColorStops","addColorStop","dash","strokeScaleEnabled","getStrokeScaleEnabled","dashEnabled","dashOffset","strokeWidth","getShadowForStrokeEnabled","_strokeFunc","_applyShadow","_a","_b","_c","color","getShadowRGBA","blur","getShadowBlur","offset","getShadowOffset","getAbsoluteScale","ratio","scaleX","scaleY","min","abs","HitContext","colorKey","_fillFuncHit","hasHitStroke","hitStrokeWidth","_strokeFuncHit"],"sources":["C:/Users/lenovo pro/Documents/gncipl-6-week/Week-6_final_project/matty-project/client/node_modules/konva/lib/Context.js"],"sourcesContent":["import { Util } from \"./Util.js\";\r\nimport { Konva } from \"./Global.js\";\r\nfunction simplifyArray(arr) {\r\n    const retArr = [], len = arr.length, util = Util;\r\n    for (let n = 0; n < len; n++) {\r\n        let val = arr[n];\r\n        if (util._isNumber(val)) {\r\n            val = Math.round(val * 1000) / 1000;\r\n        }\r\n        else if (!util._isString(val)) {\r\n            val = val + '';\r\n        }\r\n        retArr.push(val);\r\n    }\r\n    return retArr;\r\n}\r\nconst COMMA = ',', OPEN_PAREN = '(', CLOSE_PAREN = ')', OPEN_PAREN_BRACKET = '([', CLOSE_BRACKET_PAREN = '])', SEMICOLON = ';', DOUBLE_PAREN = '()', EQUALS = '=', CONTEXT_METHODS = [\r\n    'arc',\r\n    'arcTo',\r\n    'beginPath',\r\n    'bezierCurveTo',\r\n    'clearRect',\r\n    'clip',\r\n    'closePath',\r\n    'createLinearGradient',\r\n    'createPattern',\r\n    'createRadialGradient',\r\n    'drawImage',\r\n    'ellipse',\r\n    'fill',\r\n    'fillText',\r\n    'getImageData',\r\n    'createImageData',\r\n    'lineTo',\r\n    'moveTo',\r\n    'putImageData',\r\n    'quadraticCurveTo',\r\n    'rect',\r\n    'roundRect',\r\n    'restore',\r\n    'rotate',\r\n    'save',\r\n    'scale',\r\n    'setLineDash',\r\n    'setTransform',\r\n    'stroke',\r\n    'strokeText',\r\n    'transform',\r\n    'translate',\r\n];\r\nconst CONTEXT_PROPERTIES = [\r\n    'fillStyle',\r\n    'strokeStyle',\r\n    'shadowColor',\r\n    'shadowBlur',\r\n    'shadowOffsetX',\r\n    'shadowOffsetY',\r\n    'letterSpacing',\r\n    'lineCap',\r\n    'lineDashOffset',\r\n    'lineJoin',\r\n    'lineWidth',\r\n    'miterLimit',\r\n    'direction',\r\n    'font',\r\n    'textAlign',\r\n    'textBaseline',\r\n    'globalAlpha',\r\n    'globalCompositeOperation',\r\n    'imageSmoothingEnabled',\r\n    'filter',\r\n];\r\nconst traceArrMax = 100;\r\nlet _cssFiltersSupported = null;\r\nexport function isCSSFiltersSupported() {\r\n    if (_cssFiltersSupported !== null) {\r\n        return _cssFiltersSupported;\r\n    }\r\n    try {\r\n        const canvas = Util.createCanvasElement();\r\n        const ctx = canvas.getContext('2d');\r\n        if (!ctx) {\r\n            _cssFiltersSupported = false;\r\n            return false;\r\n        }\r\n        return !!ctx && 'filter' in ctx;\r\n    }\r\n    catch (e) {\r\n        _cssFiltersSupported = false;\r\n        return false;\r\n    }\r\n}\r\nexport class Context {\r\n    constructor(canvas) {\r\n        this.canvas = canvas;\r\n        if (Konva.enableTrace) {\r\n            this.traceArr = [];\r\n            this._enableTrace();\r\n        }\r\n    }\r\n    fillShape(shape) {\r\n        if (shape.fillEnabled()) {\r\n            this._fill(shape);\r\n        }\r\n    }\r\n    _fill(shape) {\r\n    }\r\n    strokeShape(shape) {\r\n        if (shape.hasStroke()) {\r\n            this._stroke(shape);\r\n        }\r\n    }\r\n    _stroke(shape) {\r\n    }\r\n    fillStrokeShape(shape) {\r\n        if (shape.attrs.fillAfterStrokeEnabled) {\r\n            this.strokeShape(shape);\r\n            this.fillShape(shape);\r\n        }\r\n        else {\r\n            this.fillShape(shape);\r\n            this.strokeShape(shape);\r\n        }\r\n    }\r\n    getTrace(relaxed, rounded) {\r\n        let traceArr = this.traceArr, len = traceArr.length, str = '', n, trace, method, args;\r\n        for (n = 0; n < len; n++) {\r\n            trace = traceArr[n];\r\n            method = trace.method;\r\n            if (method) {\r\n                args = trace.args;\r\n                str += method;\r\n                if (relaxed) {\r\n                    str += DOUBLE_PAREN;\r\n                }\r\n                else {\r\n                    if (Util._isArray(args[0])) {\r\n                        str += OPEN_PAREN_BRACKET + args.join(COMMA) + CLOSE_BRACKET_PAREN;\r\n                    }\r\n                    else {\r\n                        if (rounded) {\r\n                            args = args.map((a) => typeof a === 'number' ? Math.floor(a) : a);\r\n                        }\r\n                        str += OPEN_PAREN + args.join(COMMA) + CLOSE_PAREN;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                str += trace.property;\r\n                if (!relaxed) {\r\n                    str += EQUALS + trace.val;\r\n                }\r\n            }\r\n            str += SEMICOLON;\r\n        }\r\n        return str;\r\n    }\r\n    clearTrace() {\r\n        this.traceArr = [];\r\n    }\r\n    _trace(str) {\r\n        let traceArr = this.traceArr, len;\r\n        traceArr.push(str);\r\n        len = traceArr.length;\r\n        if (len >= traceArrMax) {\r\n            traceArr.shift();\r\n        }\r\n    }\r\n    reset() {\r\n        const pixelRatio = this.getCanvas().getPixelRatio();\r\n        this.setTransform(1 * pixelRatio, 0, 0, 1 * pixelRatio, 0, 0);\r\n    }\r\n    getCanvas() {\r\n        return this.canvas;\r\n    }\r\n    clear(bounds) {\r\n        const canvas = this.getCanvas();\r\n        if (bounds) {\r\n            this.clearRect(bounds.x || 0, bounds.y || 0, bounds.width || 0, bounds.height || 0);\r\n        }\r\n        else {\r\n            this.clearRect(0, 0, canvas.getWidth() / canvas.pixelRatio, canvas.getHeight() / canvas.pixelRatio);\r\n        }\r\n    }\r\n    _applyLineCap(shape) {\r\n        const lineCap = shape.attrs.lineCap;\r\n        if (lineCap) {\r\n            this.setAttr('lineCap', lineCap);\r\n        }\r\n    }\r\n    _applyOpacity(shape) {\r\n        const absOpacity = shape.getAbsoluteOpacity();\r\n        if (absOpacity !== 1) {\r\n            this.setAttr('globalAlpha', absOpacity);\r\n        }\r\n    }\r\n    _applyLineJoin(shape) {\r\n        const lineJoin = shape.attrs.lineJoin;\r\n        if (lineJoin) {\r\n            this.setAttr('lineJoin', lineJoin);\r\n        }\r\n    }\r\n    _applyMiterLimit(shape) {\r\n        const miterLimit = shape.attrs.miterLimit;\r\n        if (miterLimit != null) {\r\n            this.setAttr('miterLimit', miterLimit);\r\n        }\r\n    }\r\n    setAttr(attr, val) {\r\n        this._context[attr] = val;\r\n    }\r\n    arc(x, y, radius, startAngle, endAngle, counterClockwise) {\r\n        this._context.arc(x, y, radius, startAngle, endAngle, counterClockwise);\r\n    }\r\n    arcTo(x1, y1, x2, y2, radius) {\r\n        this._context.arcTo(x1, y1, x2, y2, radius);\r\n    }\r\n    beginPath() {\r\n        this._context.beginPath();\r\n    }\r\n    bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y) {\r\n        this._context.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\r\n    }\r\n    clearRect(x, y, width, height) {\r\n        this._context.clearRect(x, y, width, height);\r\n    }\r\n    clip(...args) {\r\n        this._context.clip.apply(this._context, args);\r\n    }\r\n    closePath() {\r\n        this._context.closePath();\r\n    }\r\n    createImageData(width, height) {\r\n        const a = arguments;\r\n        if (a.length === 2) {\r\n            return this._context.createImageData(width, height);\r\n        }\r\n        else if (a.length === 1) {\r\n            return this._context.createImageData(width);\r\n        }\r\n    }\r\n    createLinearGradient(x0, y0, x1, y1) {\r\n        return this._context.createLinearGradient(x0, y0, x1, y1);\r\n    }\r\n    createPattern(image, repetition) {\r\n        return this._context.createPattern(image, repetition);\r\n    }\r\n    createRadialGradient(x0, y0, r0, x1, y1, r1) {\r\n        return this._context.createRadialGradient(x0, y0, r0, x1, y1, r1);\r\n    }\r\n    drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {\r\n        const a = arguments, _context = this._context;\r\n        if (a.length === 3) {\r\n            _context.drawImage(image, sx, sy);\r\n        }\r\n        else if (a.length === 5) {\r\n            _context.drawImage(image, sx, sy, sWidth, sHeight);\r\n        }\r\n        else if (a.length === 9) {\r\n            _context.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);\r\n        }\r\n    }\r\n    ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise) {\r\n        this._context.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, counterclockwise);\r\n    }\r\n    isPointInPath(x, y, path, fillRule) {\r\n        if (path) {\r\n            return this._context.isPointInPath(path, x, y, fillRule);\r\n        }\r\n        return this._context.isPointInPath(x, y, fillRule);\r\n    }\r\n    fill(...args) {\r\n        this._context.fill.apply(this._context, args);\r\n    }\r\n    fillRect(x, y, width, height) {\r\n        this._context.fillRect(x, y, width, height);\r\n    }\r\n    strokeRect(x, y, width, height) {\r\n        this._context.strokeRect(x, y, width, height);\r\n    }\r\n    fillText(text, x, y, maxWidth) {\r\n        if (maxWidth) {\r\n            this._context.fillText(text, x, y, maxWidth);\r\n        }\r\n        else {\r\n            this._context.fillText(text, x, y);\r\n        }\r\n    }\r\n    measureText(text) {\r\n        return this._context.measureText(text);\r\n    }\r\n    getImageData(sx, sy, sw, sh) {\r\n        return this._context.getImageData(sx, sy, sw, sh);\r\n    }\r\n    lineTo(x, y) {\r\n        this._context.lineTo(x, y);\r\n    }\r\n    moveTo(x, y) {\r\n        this._context.moveTo(x, y);\r\n    }\r\n    rect(x, y, width, height) {\r\n        this._context.rect(x, y, width, height);\r\n    }\r\n    roundRect(x, y, width, height, radii) {\r\n        this._context.roundRect(x, y, width, height, radii);\r\n    }\r\n    putImageData(imageData, dx, dy) {\r\n        this._context.putImageData(imageData, dx, dy);\r\n    }\r\n    quadraticCurveTo(cpx, cpy, x, y) {\r\n        this._context.quadraticCurveTo(cpx, cpy, x, y);\r\n    }\r\n    restore() {\r\n        this._context.restore();\r\n    }\r\n    rotate(angle) {\r\n        this._context.rotate(angle);\r\n    }\r\n    save() {\r\n        this._context.save();\r\n    }\r\n    scale(x, y) {\r\n        this._context.scale(x, y);\r\n    }\r\n    setLineDash(segments) {\r\n        if (this._context.setLineDash) {\r\n            this._context.setLineDash(segments);\r\n        }\r\n        else if ('mozDash' in this._context) {\r\n            this._context['mozDash'] = segments;\r\n        }\r\n        else if ('webkitLineDash' in this._context) {\r\n            this._context['webkitLineDash'] = segments;\r\n        }\r\n    }\r\n    getLineDash() {\r\n        return this._context.getLineDash();\r\n    }\r\n    setTransform(a, b, c, d, e, f) {\r\n        this._context.setTransform(a, b, c, d, e, f);\r\n    }\r\n    stroke(path2d) {\r\n        if (path2d) {\r\n            this._context.stroke(path2d);\r\n        }\r\n        else {\r\n            this._context.stroke();\r\n        }\r\n    }\r\n    strokeText(text, x, y, maxWidth) {\r\n        this._context.strokeText(text, x, y, maxWidth);\r\n    }\r\n    transform(a, b, c, d, e, f) {\r\n        this._context.transform(a, b, c, d, e, f);\r\n    }\r\n    translate(x, y) {\r\n        this._context.translate(x, y);\r\n    }\r\n    _enableTrace() {\r\n        let that = this, len = CONTEXT_METHODS.length, origSetter = this.setAttr, n, args;\r\n        const func = function (methodName) {\r\n            let origMethod = that[methodName], ret;\r\n            that[methodName] = function () {\r\n                args = simplifyArray(Array.prototype.slice.call(arguments, 0));\r\n                ret = origMethod.apply(that, arguments);\r\n                that._trace({\r\n                    method: methodName,\r\n                    args: args,\r\n                });\r\n                return ret;\r\n            };\r\n        };\r\n        for (n = 0; n < len; n++) {\r\n            func(CONTEXT_METHODS[n]);\r\n        }\r\n        that.setAttr = function () {\r\n            origSetter.apply(that, arguments);\r\n            const prop = arguments[0];\r\n            let val = arguments[1];\r\n            if (prop === 'shadowOffsetX' ||\r\n                prop === 'shadowOffsetY' ||\r\n                prop === 'shadowBlur') {\r\n                val = val / this.canvas.getPixelRatio();\r\n            }\r\n            that._trace({\r\n                property: prop,\r\n                val: val,\r\n            });\r\n        };\r\n    }\r\n    _applyGlobalCompositeOperation(node) {\r\n        const op = node.attrs.globalCompositeOperation;\r\n        const def = !op || op === 'source-over';\r\n        if (!def) {\r\n            this.setAttr('globalCompositeOperation', op);\r\n        }\r\n    }\r\n}\r\nCONTEXT_PROPERTIES.forEach(function (prop) {\r\n    Object.defineProperty(Context.prototype, prop, {\r\n        get() {\r\n            return this._context[prop];\r\n        },\r\n        set(val) {\r\n            this._context[prop] = val;\r\n        },\r\n    });\r\n});\r\nexport class SceneContext extends Context {\r\n    constructor(canvas, { willReadFrequently = false } = {}) {\r\n        super(canvas);\r\n        this._context = canvas._canvas.getContext('2d', {\r\n            willReadFrequently,\r\n        });\r\n    }\r\n    _fillColor(shape) {\r\n        const fill = shape.fill();\r\n        this.setAttr('fillStyle', fill);\r\n        shape._fillFunc(this);\r\n    }\r\n    _fillPattern(shape) {\r\n        this.setAttr('fillStyle', shape._getFillPattern());\r\n        shape._fillFunc(this);\r\n    }\r\n    _fillLinearGradient(shape) {\r\n        const grd = shape._getLinearGradient();\r\n        if (grd) {\r\n            this.setAttr('fillStyle', grd);\r\n            shape._fillFunc(this);\r\n        }\r\n    }\r\n    _fillRadialGradient(shape) {\r\n        const grd = shape._getRadialGradient();\r\n        if (grd) {\r\n            this.setAttr('fillStyle', grd);\r\n            shape._fillFunc(this);\r\n        }\r\n    }\r\n    _fill(shape) {\r\n        const hasColor = shape.fill(), fillPriority = shape.getFillPriority();\r\n        if (hasColor && fillPriority === 'color') {\r\n            this._fillColor(shape);\r\n            return;\r\n        }\r\n        const hasPattern = shape.getFillPatternImage();\r\n        if (hasPattern && fillPriority === 'pattern') {\r\n            this._fillPattern(shape);\r\n            return;\r\n        }\r\n        const hasLinearGradient = shape.getFillLinearGradientColorStops();\r\n        if (hasLinearGradient && fillPriority === 'linear-gradient') {\r\n            this._fillLinearGradient(shape);\r\n            return;\r\n        }\r\n        const hasRadialGradient = shape.getFillRadialGradientColorStops();\r\n        if (hasRadialGradient && fillPriority === 'radial-gradient') {\r\n            this._fillRadialGradient(shape);\r\n            return;\r\n        }\r\n        if (hasColor) {\r\n            this._fillColor(shape);\r\n        }\r\n        else if (hasPattern) {\r\n            this._fillPattern(shape);\r\n        }\r\n        else if (hasLinearGradient) {\r\n            this._fillLinearGradient(shape);\r\n        }\r\n        else if (hasRadialGradient) {\r\n            this._fillRadialGradient(shape);\r\n        }\r\n    }\r\n    _strokeLinearGradient(shape) {\r\n        const start = shape.getStrokeLinearGradientStartPoint(), end = shape.getStrokeLinearGradientEndPoint(), colorStops = shape.getStrokeLinearGradientColorStops(), grd = this.createLinearGradient(start.x, start.y, end.x, end.y);\r\n        if (colorStops) {\r\n            for (let n = 0; n < colorStops.length; n += 2) {\r\n                grd.addColorStop(colorStops[n], colorStops[n + 1]);\r\n            }\r\n            this.setAttr('strokeStyle', grd);\r\n        }\r\n    }\r\n    _stroke(shape) {\r\n        const dash = shape.dash(), strokeScaleEnabled = shape.getStrokeScaleEnabled();\r\n        if (shape.hasStroke()) {\r\n            if (!strokeScaleEnabled) {\r\n                this.save();\r\n                const pixelRatio = this.getCanvas().getPixelRatio();\r\n                this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\r\n            }\r\n            this._applyLineCap(shape);\r\n            if (dash && shape.dashEnabled()) {\r\n                this.setLineDash(dash);\r\n                this.setAttr('lineDashOffset', shape.dashOffset());\r\n            }\r\n            this.setAttr('lineWidth', shape.strokeWidth());\r\n            if (!shape.getShadowForStrokeEnabled()) {\r\n                this.setAttr('shadowColor', 'rgba(0,0,0,0)');\r\n            }\r\n            const hasLinearGradient = shape.getStrokeLinearGradientColorStops();\r\n            if (hasLinearGradient) {\r\n                this._strokeLinearGradient(shape);\r\n            }\r\n            else {\r\n                this.setAttr('strokeStyle', shape.stroke());\r\n            }\r\n            shape._strokeFunc(this);\r\n            if (!strokeScaleEnabled) {\r\n                this.restore();\r\n            }\r\n        }\r\n    }\r\n    _applyShadow(shape) {\r\n        var _a, _b, _c;\r\n        const color = (_a = shape.getShadowRGBA()) !== null && _a !== void 0 ? _a : 'black', blur = (_b = shape.getShadowBlur()) !== null && _b !== void 0 ? _b : 5, offset = (_c = shape.getShadowOffset()) !== null && _c !== void 0 ? _c : {\r\n            x: 0,\r\n            y: 0,\r\n        }, scale = shape.getAbsoluteScale(), ratio = this.canvas.getPixelRatio(), scaleX = scale.x * ratio, scaleY = scale.y * ratio;\r\n        this.setAttr('shadowColor', color);\r\n        this.setAttr('shadowBlur', blur * Math.min(Math.abs(scaleX), Math.abs(scaleY)));\r\n        this.setAttr('shadowOffsetX', offset.x * scaleX);\r\n        this.setAttr('shadowOffsetY', offset.y * scaleY);\r\n    }\r\n}\r\nexport class HitContext extends Context {\r\n    constructor(canvas) {\r\n        super(canvas);\r\n        this._context = canvas._canvas.getContext('2d', {\r\n            willReadFrequently: true,\r\n        });\r\n    }\r\n    _fill(shape) {\r\n        this.save();\r\n        this.setAttr('fillStyle', shape.colorKey);\r\n        shape._fillFuncHit(this);\r\n        this.restore();\r\n    }\r\n    strokeShape(shape) {\r\n        if (shape.hasHitStroke()) {\r\n            this._stroke(shape);\r\n        }\r\n    }\r\n    _stroke(shape) {\r\n        if (shape.hasHitStroke()) {\r\n            const strokeScaleEnabled = shape.getStrokeScaleEnabled();\r\n            if (!strokeScaleEnabled) {\r\n                this.save();\r\n                const pixelRatio = this.getCanvas().getPixelRatio();\r\n                this.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);\r\n            }\r\n            this._applyLineCap(shape);\r\n            const hitStrokeWidth = shape.hitStrokeWidth();\r\n            const strokeWidth = hitStrokeWidth === 'auto' ? shape.strokeWidth() : hitStrokeWidth;\r\n            this.setAttr('lineWidth', strokeWidth);\r\n            this.setAttr('strokeStyle', shape.colorKey);\r\n            shape._strokeFuncHit(this);\r\n            if (!strokeScaleEnabled) {\r\n                this.restore();\r\n            }\r\n        }\r\n    }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}