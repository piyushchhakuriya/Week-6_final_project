{"ast":null,"code":"import { Util } from \"./Util.js\";\nimport { Factory } from \"./Factory.js\";\nimport { Container } from \"./Container.js\";\nimport { Konva } from \"./Global.js\";\nimport { SceneCanvas, HitCanvas } from \"./Canvas.js\";\nimport { DD } from \"./DragAndDrop.js\";\nimport { _registerNode } from \"./Global.js\";\nimport * as PointerEvents from \"./PointerEvents.js\";\nconst STAGE = 'Stage',\n  STRING = 'string',\n  PX = 'px',\n  MOUSEOUT = 'mouseout',\n  MOUSELEAVE = 'mouseleave',\n  MOUSEOVER = 'mouseover',\n  MOUSEENTER = 'mouseenter',\n  MOUSEMOVE = 'mousemove',\n  MOUSEDOWN = 'mousedown',\n  MOUSEUP = 'mouseup',\n  POINTERMOVE = 'pointermove',\n  POINTERDOWN = 'pointerdown',\n  POINTERUP = 'pointerup',\n  POINTERCANCEL = 'pointercancel',\n  LOSTPOINTERCAPTURE = 'lostpointercapture',\n  POINTEROUT = 'pointerout',\n  POINTERLEAVE = 'pointerleave',\n  POINTEROVER = 'pointerover',\n  POINTERENTER = 'pointerenter',\n  CONTEXTMENU = 'contextmenu',\n  TOUCHSTART = 'touchstart',\n  TOUCHEND = 'touchend',\n  TOUCHMOVE = 'touchmove',\n  TOUCHCANCEL = 'touchcancel',\n  WHEEL = 'wheel',\n  MAX_LAYERS_NUMBER = 5,\n  EVENTS = [[MOUSEENTER, '_pointerenter'], [MOUSEDOWN, '_pointerdown'], [MOUSEMOVE, '_pointermove'], [MOUSEUP, '_pointerup'], [MOUSELEAVE, '_pointerleave'], [TOUCHSTART, '_pointerdown'], [TOUCHMOVE, '_pointermove'], [TOUCHEND, '_pointerup'], [TOUCHCANCEL, '_pointercancel'], [MOUSEOVER, '_pointerover'], [WHEEL, '_wheel'], [CONTEXTMENU, '_contextmenu'], [POINTERDOWN, '_pointerdown'], [POINTERMOVE, '_pointermove'], [POINTERUP, '_pointerup'], [POINTERCANCEL, '_pointercancel'], [POINTERLEAVE, '_pointerleave'], [LOSTPOINTERCAPTURE, '_lostpointercapture']];\nconst EVENTS_MAP = {\n  mouse: {\n    [POINTEROUT]: MOUSEOUT,\n    [POINTERLEAVE]: MOUSELEAVE,\n    [POINTEROVER]: MOUSEOVER,\n    [POINTERENTER]: MOUSEENTER,\n    [POINTERMOVE]: MOUSEMOVE,\n    [POINTERDOWN]: MOUSEDOWN,\n    [POINTERUP]: MOUSEUP,\n    [POINTERCANCEL]: 'mousecancel',\n    pointerclick: 'click',\n    pointerdblclick: 'dblclick'\n  },\n  touch: {\n    [POINTEROUT]: 'touchout',\n    [POINTERLEAVE]: 'touchleave',\n    [POINTEROVER]: 'touchover',\n    [POINTERENTER]: 'touchenter',\n    [POINTERMOVE]: TOUCHMOVE,\n    [POINTERDOWN]: TOUCHSTART,\n    [POINTERUP]: TOUCHEND,\n    [POINTERCANCEL]: TOUCHCANCEL,\n    pointerclick: 'tap',\n    pointerdblclick: 'dbltap'\n  },\n  pointer: {\n    [POINTEROUT]: POINTEROUT,\n    [POINTERLEAVE]: POINTERLEAVE,\n    [POINTEROVER]: POINTEROVER,\n    [POINTERENTER]: POINTERENTER,\n    [POINTERMOVE]: POINTERMOVE,\n    [POINTERDOWN]: POINTERDOWN,\n    [POINTERUP]: POINTERUP,\n    [POINTERCANCEL]: POINTERCANCEL,\n    pointerclick: 'pointerclick',\n    pointerdblclick: 'pointerdblclick'\n  }\n};\nconst getEventType = type => {\n  if (type.indexOf('pointer') >= 0) {\n    return 'pointer';\n  }\n  if (type.indexOf('touch') >= 0) {\n    return 'touch';\n  }\n  return 'mouse';\n};\nconst getEventsMap = eventType => {\n  const type = getEventType(eventType);\n  if (type === 'pointer') {\n    return Konva.pointerEventsEnabled && EVENTS_MAP.pointer;\n  }\n  if (type === 'touch') {\n    return EVENTS_MAP.touch;\n  }\n  if (type === 'mouse') {\n    return EVENTS_MAP.mouse;\n  }\n};\nfunction checkNoClip(attrs = {}) {\n  if (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) {\n    Util.warn('Stage does not support clipping. Please use clip for Layers or Groups.');\n  }\n  return attrs;\n}\nconst NO_POINTERS_MESSAGE = `Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);`;\nexport const stages = [];\nexport class Stage extends Container {\n  constructor(config) {\n    super(checkNoClip(config));\n    this._pointerPositions = [];\n    this._changedPointerPositions = [];\n    this._buildDOM();\n    this._bindContentEvents();\n    stages.push(this);\n    this.on('widthChange.konva heightChange.konva', this._resizeDOM);\n    this.on('visibleChange.konva', this._checkVisibility);\n    this.on('clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva', () => {\n      checkNoClip(this.attrs);\n    });\n    this._checkVisibility();\n  }\n  _validateAdd(child) {\n    const isLayer = child.getType() === 'Layer';\n    const isFastLayer = child.getType() === 'FastLayer';\n    const valid = isLayer || isFastLayer;\n    if (!valid) {\n      Util.throw('You may only add layers to the stage.');\n    }\n  }\n  _checkVisibility() {\n    if (!this.content) {\n      return;\n    }\n    const style = this.visible() ? '' : 'none';\n    this.content.style.display = style;\n  }\n  setContainer(container) {\n    if (typeof container === STRING) {\n      let id;\n      if (container.charAt(0) === '.') {\n        const className = container.slice(1);\n        container = document.getElementsByClassName(className)[0];\n      } else {\n        if (container.charAt(0) !== '#') {\n          id = container;\n        } else {\n          id = container.slice(1);\n        }\n        container = document.getElementById(id);\n      }\n      if (!container) {\n        throw 'Can not find container in document with id ' + id;\n      }\n    }\n    this._setAttr('container', container);\n    if (this.content) {\n      if (this.content.parentElement) {\n        this.content.parentElement.removeChild(this.content);\n      }\n      container.appendChild(this.content);\n    }\n    return this;\n  }\n  shouldDrawHit() {\n    return true;\n  }\n  clear() {\n    const layers = this.children,\n      len = layers.length;\n    for (let n = 0; n < len; n++) {\n      layers[n].clear();\n    }\n    return this;\n  }\n  clone(obj) {\n    if (!obj) {\n      obj = {};\n    }\n    obj.container = typeof document !== 'undefined' && document.createElement('div');\n    return Container.prototype.clone.call(this, obj);\n  }\n  destroy() {\n    super.destroy();\n    const content = this.content;\n    if (content && Util._isInDocument(content)) {\n      this.container().removeChild(content);\n    }\n    const index = stages.indexOf(this);\n    if (index > -1) {\n      stages.splice(index, 1);\n    }\n    Util.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas);\n    return this;\n  }\n  getPointerPosition() {\n    const pos = this._pointerPositions[0] || this._changedPointerPositions[0];\n    if (!pos) {\n      Util.warn(NO_POINTERS_MESSAGE);\n      return null;\n    }\n    return {\n      x: pos.x,\n      y: pos.y\n    };\n  }\n  _getPointerById(id) {\n    return this._pointerPositions.find(p => p.id === id);\n  }\n  getPointersPositions() {\n    return this._pointerPositions;\n  }\n  getStage() {\n    return this;\n  }\n  getContent() {\n    return this.content;\n  }\n  _toKonvaCanvas(config) {\n    config = {\n      ...config\n    };\n    config.x = config.x || 0;\n    config.y = config.y || 0;\n    config.width = config.width || this.width();\n    config.height = config.height || this.height();\n    const canvas = new SceneCanvas({\n      width: config.width,\n      height: config.height,\n      pixelRatio: config.pixelRatio || 1\n    });\n    const _context = canvas.getContext()._context;\n    const layers = this.children;\n    if (config.x || config.y) {\n      _context.translate(-1 * config.x, -1 * config.y);\n    }\n    layers.forEach(function (layer) {\n      if (!layer.isVisible()) {\n        return;\n      }\n      const layerCanvas = layer._toKonvaCanvas(config);\n      _context.drawImage(layerCanvas._canvas, config.x, config.y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());\n    });\n    return canvas;\n  }\n  getIntersection(pos) {\n    if (!pos) {\n      return null;\n    }\n    const layers = this.children,\n      len = layers.length,\n      end = len - 1;\n    for (let n = end; n >= 0; n--) {\n      const shape = layers[n].getIntersection(pos);\n      if (shape) {\n        return shape;\n      }\n    }\n    return null;\n  }\n  _resizeDOM() {\n    const width = this.width();\n    const height = this.height();\n    if (this.content) {\n      this.content.style.width = width + PX;\n      this.content.style.height = height + PX;\n    }\n    this.bufferCanvas.setSize(width, height);\n    this.bufferHitCanvas.setSize(width, height);\n    this.children.forEach(layer => {\n      layer.setSize({\n        width,\n        height\n      });\n      layer.draw();\n    });\n  }\n  add(layer, ...rest) {\n    if (arguments.length > 1) {\n      for (let i = 0; i < arguments.length; i++) {\n        this.add(arguments[i]);\n      }\n      return this;\n    }\n    super.add(layer);\n    const length = this.children.length;\n    if (length > MAX_LAYERS_NUMBER) {\n      Util.warn('The stage has ' + length + ' layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group.');\n    }\n    layer.setSize({\n      width: this.width(),\n      height: this.height()\n    });\n    layer.draw();\n    if (Konva.isBrowser) {\n      this.content.appendChild(layer.canvas._canvas);\n    }\n    return this;\n  }\n  getParent() {\n    return null;\n  }\n  getLayer() {\n    return null;\n  }\n  hasPointerCapture(pointerId) {\n    return PointerEvents.hasPointerCapture(pointerId, this);\n  }\n  setPointerCapture(pointerId) {\n    PointerEvents.setPointerCapture(pointerId, this);\n  }\n  releaseCapture(pointerId) {\n    PointerEvents.releaseCapture(pointerId, this);\n  }\n  getLayers() {\n    return this.children;\n  }\n  _bindContentEvents() {\n    if (!Konva.isBrowser) {\n      return;\n    }\n    EVENTS.forEach(([event, methodName]) => {\n      this.content.addEventListener(event, evt => {\n        this[methodName](evt);\n      }, {\n        passive: false\n      });\n    });\n  }\n  _pointerenter(evt) {\n    this.setPointersPositions(evt);\n    const events = getEventsMap(evt.type);\n    if (events) {\n      this._fire(events.pointerenter, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n    }\n  }\n  _pointerover(evt) {\n    this.setPointersPositions(evt);\n    const events = getEventsMap(evt.type);\n    if (events) {\n      this._fire(events.pointerover, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n    }\n  }\n  _getTargetShape(evenType) {\n    let shape = this[evenType + 'targetShape'];\n    if (shape && !shape.getStage()) {\n      shape = null;\n    }\n    return shape;\n  }\n  _pointerleave(evt) {\n    const events = getEventsMap(evt.type);\n    const eventType = getEventType(evt.type);\n    if (!events) {\n      return;\n    }\n    this.setPointersPositions(evt);\n    const targetShape = this._getTargetShape(eventType);\n    const eventsEnabled = !(Konva.isDragging() || Konva.isTransforming()) || Konva.hitOnDragEnabled;\n    if (targetShape && eventsEnabled) {\n      targetShape._fireAndBubble(events.pointerout, {\n        evt: evt\n      });\n      targetShape._fireAndBubble(events.pointerleave, {\n        evt: evt\n      });\n      this._fire(events.pointerleave, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n      this[eventType + 'targetShape'] = null;\n    } else if (eventsEnabled) {\n      this._fire(events.pointerleave, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n      this._fire(events.pointerout, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n    }\n    this.pointerPos = null;\n    this._pointerPositions = [];\n  }\n  _pointerdown(evt) {\n    const events = getEventsMap(evt.type);\n    const eventType = getEventType(evt.type);\n    if (!events) {\n      return;\n    }\n    this.setPointersPositions(evt);\n    let triggeredOnShape = false;\n    this._changedPointerPositions.forEach(pos => {\n      const shape = this.getIntersection(pos);\n      DD.justDragged = false;\n      Konva['_' + eventType + 'ListenClick'] = true;\n      if (!shape || !shape.isListening()) {\n        this[eventType + 'ClickStartShape'] = undefined;\n        return;\n      }\n      if (Konva.capturePointerEventsEnabled) {\n        shape.setPointerCapture(pos.id);\n      }\n      this[eventType + 'ClickStartShape'] = shape;\n      shape._fireAndBubble(events.pointerdown, {\n        evt: evt,\n        pointerId: pos.id\n      });\n      triggeredOnShape = true;\n      const isTouch = evt.type.indexOf('touch') >= 0;\n      if (shape.preventDefault() && evt.cancelable && isTouch) {\n        evt.preventDefault();\n      }\n    });\n    if (!triggeredOnShape) {\n      this._fire(events.pointerdown, {\n        evt: evt,\n        target: this,\n        currentTarget: this,\n        pointerId: this._pointerPositions[0].id\n      });\n    }\n  }\n  _pointermove(evt) {\n    const events = getEventsMap(evt.type);\n    const eventType = getEventType(evt.type);\n    if (!events) {\n      return;\n    }\n    const isTouchPointer = evt.type.indexOf('touch') >= 0 || evt.pointerType === 'touch';\n    if (Konva.isDragging() && DD.node.preventDefault() && evt.cancelable && isTouchPointer) {\n      evt.preventDefault();\n    }\n    this.setPointersPositions(evt);\n    const eventsEnabled = !(Konva.isDragging() || Konva.isTransforming()) || Konva.hitOnDragEnabled;\n    if (!eventsEnabled) {\n      return;\n    }\n    const processedShapesIds = {};\n    let triggeredOnShape = false;\n    const targetShape = this._getTargetShape(eventType);\n    this._changedPointerPositions.forEach(pos => {\n      const shape = PointerEvents.getCapturedShape(pos.id) || this.getIntersection(pos);\n      const pointerId = pos.id;\n      const event = {\n        evt: evt,\n        pointerId\n      };\n      const differentTarget = targetShape !== shape;\n      if (differentTarget && targetShape) {\n        targetShape._fireAndBubble(events.pointerout, {\n          ...event\n        }, shape);\n        targetShape._fireAndBubble(events.pointerleave, {\n          ...event\n        }, shape);\n      }\n      if (shape) {\n        if (processedShapesIds[shape._id]) {\n          return;\n        }\n        processedShapesIds[shape._id] = true;\n      }\n      if (shape && shape.isListening()) {\n        triggeredOnShape = true;\n        if (differentTarget) {\n          shape._fireAndBubble(events.pointerover, {\n            ...event\n          }, targetShape);\n          shape._fireAndBubble(events.pointerenter, {\n            ...event\n          }, targetShape);\n          this[eventType + 'targetShape'] = shape;\n        }\n        shape._fireAndBubble(events.pointermove, {\n          ...event\n        });\n      } else {\n        if (targetShape) {\n          this._fire(events.pointerover, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n            pointerId\n          });\n          this[eventType + 'targetShape'] = null;\n        }\n      }\n    });\n    if (!triggeredOnShape) {\n      this._fire(events.pointermove, {\n        evt: evt,\n        target: this,\n        currentTarget: this,\n        pointerId: this._changedPointerPositions[0].id\n      });\n    }\n  }\n  _pointerup(evt) {\n    const events = getEventsMap(evt.type);\n    const eventType = getEventType(evt.type);\n    if (!events) {\n      return;\n    }\n    this.setPointersPositions(evt);\n    const clickStartShape = this[eventType + 'ClickStartShape'];\n    const clickEndShape = this[eventType + 'ClickEndShape'];\n    const processedShapesIds = {};\n    let skipPointerUpTrigger = false;\n    this._changedPointerPositions.forEach(pos => {\n      const shape = PointerEvents.getCapturedShape(pos.id) || this.getIntersection(pos);\n      if (shape) {\n        shape.releaseCapture(pos.id);\n        if (processedShapesIds[shape._id]) {\n          return;\n        }\n        processedShapesIds[shape._id] = true;\n      }\n      const pointerId = pos.id;\n      const event = {\n        evt: evt,\n        pointerId\n      };\n      let fireDblClick = false;\n      if (Konva['_' + eventType + 'InDblClickWindow']) {\n        fireDblClick = true;\n        clearTimeout(this[eventType + 'DblTimeout']);\n      } else if (!DD.justDragged) {\n        Konva['_' + eventType + 'InDblClickWindow'] = true;\n        clearTimeout(this[eventType + 'DblTimeout']);\n      }\n      this[eventType + 'DblTimeout'] = setTimeout(function () {\n        Konva['_' + eventType + 'InDblClickWindow'] = false;\n      }, Konva.dblClickWindow);\n      if (shape && shape.isListening()) {\n        skipPointerUpTrigger = true;\n        this[eventType + 'ClickEndShape'] = shape;\n        shape._fireAndBubble(events.pointerup, {\n          ...event\n        });\n        if (Konva['_' + eventType + 'ListenClick'] && clickStartShape && clickStartShape === shape) {\n          shape._fireAndBubble(events.pointerclick, {\n            ...event\n          });\n          if (fireDblClick && clickEndShape && clickEndShape === shape) {\n            shape._fireAndBubble(events.pointerdblclick, {\n              ...event\n            });\n          }\n        }\n      } else {\n        this[eventType + 'ClickEndShape'] = null;\n        if (!skipPointerUpTrigger) {\n          this._fire(events.pointerup, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n            pointerId: this._changedPointerPositions[0].id\n          });\n          skipPointerUpTrigger = true;\n        }\n        if (Konva['_' + eventType + 'ListenClick']) {\n          this._fire(events.pointerclick, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n            pointerId\n          });\n        }\n        if (fireDblClick) {\n          this._fire(events.pointerdblclick, {\n            evt: evt,\n            target: this,\n            currentTarget: this,\n            pointerId\n          });\n        }\n      }\n    });\n    if (!skipPointerUpTrigger) {\n      this._fire(events.pointerup, {\n        evt: evt,\n        target: this,\n        currentTarget: this,\n        pointerId: this._changedPointerPositions[0].id\n      });\n    }\n    Konva['_' + eventType + 'ListenClick'] = false;\n    if (evt.cancelable && eventType !== 'touch' && eventType !== 'pointer') {\n      evt.preventDefault();\n    }\n  }\n  _contextmenu(evt) {\n    this.setPointersPositions(evt);\n    const shape = this.getIntersection(this.getPointerPosition());\n    if (shape && shape.isListening()) {\n      shape._fireAndBubble(CONTEXTMENU, {\n        evt: evt\n      });\n    } else {\n      this._fire(CONTEXTMENU, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n    }\n  }\n  _wheel(evt) {\n    this.setPointersPositions(evt);\n    const shape = this.getIntersection(this.getPointerPosition());\n    if (shape && shape.isListening()) {\n      shape._fireAndBubble(WHEEL, {\n        evt: evt\n      });\n    } else {\n      this._fire(WHEEL, {\n        evt: evt,\n        target: this,\n        currentTarget: this\n      });\n    }\n  }\n  _pointercancel(evt) {\n    this.setPointersPositions(evt);\n    const shape = PointerEvents.getCapturedShape(evt.pointerId) || this.getIntersection(this.getPointerPosition());\n    if (shape) {\n      shape._fireAndBubble(POINTERUP, PointerEvents.createEvent(evt));\n    }\n    PointerEvents.releaseCapture(evt.pointerId);\n  }\n  _lostpointercapture(evt) {\n    PointerEvents.releaseCapture(evt.pointerId);\n  }\n  setPointersPositions(evt) {\n    const contentPosition = this._getContentPosition();\n    let x = null,\n      y = null;\n    evt = evt ? evt : window.event;\n    if (evt.touches !== undefined) {\n      this._pointerPositions = [];\n      this._changedPointerPositions = [];\n      Array.prototype.forEach.call(evt.touches, touch => {\n        this._pointerPositions.push({\n          id: touch.identifier,\n          x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\n          y: (touch.clientY - contentPosition.top) / contentPosition.scaleY\n        });\n      });\n      Array.prototype.forEach.call(evt.changedTouches || evt.touches, touch => {\n        this._changedPointerPositions.push({\n          id: touch.identifier,\n          x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\n          y: (touch.clientY - contentPosition.top) / contentPosition.scaleY\n        });\n      });\n    } else {\n      x = (evt.clientX - contentPosition.left) / contentPosition.scaleX;\n      y = (evt.clientY - contentPosition.top) / contentPosition.scaleY;\n      this.pointerPos = {\n        x: x,\n        y: y\n      };\n      this._pointerPositions = [{\n        x,\n        y,\n        id: Util._getFirstPointerId(evt)\n      }];\n      this._changedPointerPositions = [{\n        x,\n        y,\n        id: Util._getFirstPointerId(evt)\n      }];\n    }\n  }\n  _setPointerPosition(evt) {\n    Util.warn('Method _setPointerPosition is deprecated. Use \"stage.setPointersPositions(event)\" instead.');\n    this.setPointersPositions(evt);\n  }\n  _getContentPosition() {\n    if (!this.content || !this.content.getBoundingClientRect) {\n      return {\n        top: 0,\n        left: 0,\n        scaleX: 1,\n        scaleY: 1\n      };\n    }\n    const rect = this.content.getBoundingClientRect();\n    return {\n      top: rect.top,\n      left: rect.left,\n      scaleX: rect.width / this.content.clientWidth || 1,\n      scaleY: rect.height / this.content.clientHeight || 1\n    };\n  }\n  _buildDOM() {\n    this.bufferCanvas = new SceneCanvas({\n      width: this.width(),\n      height: this.height()\n    });\n    this.bufferHitCanvas = new HitCanvas({\n      pixelRatio: 1,\n      width: this.width(),\n      height: this.height()\n    });\n    if (!Konva.isBrowser) {\n      return;\n    }\n    const container = this.container();\n    if (!container) {\n      throw 'Stage has no container. A container is required.';\n    }\n    container.innerHTML = '';\n    this.content = document.createElement('div');\n    this.content.style.position = 'relative';\n    this.content.style.userSelect = 'none';\n    this.content.className = 'konvajs-content';\n    this.content.setAttribute('role', 'presentation');\n    container.appendChild(this.content);\n    this._resizeDOM();\n  }\n  cache() {\n    Util.warn('Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.');\n    return this;\n  }\n  clearCache() {\n    return this;\n  }\n  batchDraw() {\n    this.getChildren().forEach(function (layer) {\n      layer.batchDraw();\n    });\n    return this;\n  }\n}\nStage.prototype.nodeType = STAGE;\n_registerNode(Stage);\nFactory.addGetterSetter(Stage, 'container');\nif (Konva.isBrowser) {\n  document.addEventListener('visibilitychange', () => {\n    stages.forEach(stage => {\n      stage.batchDraw();\n    });\n  });\n}","map":{"version":3,"names":["Util","Factory","Container","Konva","SceneCanvas","HitCanvas","DD","_registerNode","PointerEvents","STAGE","STRING","PX","MOUSEOUT","MOUSELEAVE","MOUSEOVER","MOUSEENTER","MOUSEMOVE","MOUSEDOWN","MOUSEUP","POINTERMOVE","POINTERDOWN","POINTERUP","POINTERCANCEL","LOSTPOINTERCAPTURE","POINTEROUT","POINTERLEAVE","POINTEROVER","POINTERENTER","CONTEXTMENU","TOUCHSTART","TOUCHEND","TOUCHMOVE","TOUCHCANCEL","WHEEL","MAX_LAYERS_NUMBER","EVENTS","EVENTS_MAP","mouse","pointerclick","pointerdblclick","touch","pointer","getEventType","type","indexOf","getEventsMap","eventType","pointerEventsEnabled","checkNoClip","attrs","clipFunc","clipWidth","clipHeight","warn","NO_POINTERS_MESSAGE","stages","Stage","constructor","config","_pointerPositions","_changedPointerPositions","_buildDOM","_bindContentEvents","push","on","_resizeDOM","_checkVisibility","_validateAdd","child","isLayer","getType","isFastLayer","valid","throw","content","style","visible","display","setContainer","container","id","charAt","className","slice","document","getElementsByClassName","getElementById","_setAttr","parentElement","removeChild","appendChild","shouldDrawHit","clear","layers","children","len","length","n","clone","obj","createElement","prototype","call","destroy","_isInDocument","index","splice","releaseCanvas","bufferCanvas","_canvas","bufferHitCanvas","getPointerPosition","pos","x","y","_getPointerById","find","p","getPointersPositions","getStage","getContent","_toKonvaCanvas","width","height","canvas","pixelRatio","_context","getContext","translate","forEach","layer","isVisible","layerCanvas","drawImage","getWidth","getPixelRatio","getHeight","getIntersection","end","shape","setSize","draw","add","rest","arguments","i","isBrowser","getParent","getLayer","hasPointerCapture","pointerId","setPointerCapture","releaseCapture","getLayers","event","methodName","addEventListener","evt","passive","_pointerenter","setPointersPositions","events","_fire","pointerenter","target","currentTarget","_pointerover","pointerover","_getTargetShape","evenType","_pointerleave","targetShape","eventsEnabled","isDragging","isTransforming","hitOnDragEnabled","_fireAndBubble","pointerout","pointerleave","pointerPos","_pointerdown","triggeredOnShape","justDragged","isListening","undefined","capturePointerEventsEnabled","pointerdown","isTouch","preventDefault","cancelable","_pointermove","isTouchPointer","pointerType","node","processedShapesIds","getCapturedShape","differentTarget","_id","pointermove","_pointerup","clickStartShape","clickEndShape","skipPointerUpTrigger","fireDblClick","clearTimeout","setTimeout","dblClickWindow","pointerup","_contextmenu","_wheel","_pointercancel","createEvent","_lostpointercapture","contentPosition","_getContentPosition","window","touches","Array","identifier","clientX","left","scaleX","clientY","top","scaleY","changedTouches","_getFirstPointerId","_setPointerPosition","getBoundingClientRect","rect","clientWidth","clientHeight","innerHTML","position","userSelect","setAttribute","cache","clearCache","batchDraw","getChildren","nodeType","addGetterSetter","stage"],"sources":["C:/Users/lenovo pro/Documents/gncipl-6-week/Week-6_final_project/matty-project/client/node_modules/konva/lib/Stage.js"],"sourcesContent":["import { Util } from \"./Util.js\";\r\nimport { Factory } from \"./Factory.js\";\r\nimport { Container } from \"./Container.js\";\r\nimport { Konva } from \"./Global.js\";\r\nimport { SceneCanvas, HitCanvas } from \"./Canvas.js\";\r\nimport { DD } from \"./DragAndDrop.js\";\r\nimport { _registerNode } from \"./Global.js\";\r\nimport * as PointerEvents from \"./PointerEvents.js\";\r\nconst STAGE = 'Stage', STRING = 'string', PX = 'px', MOUSEOUT = 'mouseout', MOUSELEAVE = 'mouseleave', MOUSEOVER = 'mouseover', MOUSEENTER = 'mouseenter', MOUSEMOVE = 'mousemove', MOUSEDOWN = 'mousedown', MOUSEUP = 'mouseup', POINTERMOVE = 'pointermove', POINTERDOWN = 'pointerdown', POINTERUP = 'pointerup', POINTERCANCEL = 'pointercancel', LOSTPOINTERCAPTURE = 'lostpointercapture', POINTEROUT = 'pointerout', POINTERLEAVE = 'pointerleave', POINTEROVER = 'pointerover', POINTERENTER = 'pointerenter', CONTEXTMENU = 'contextmenu', TOUCHSTART = 'touchstart', TOUCHEND = 'touchend', TOUCHMOVE = 'touchmove', TOUCHCANCEL = 'touchcancel', WHEEL = 'wheel', MAX_LAYERS_NUMBER = 5, EVENTS = [\r\n    [MOUSEENTER, '_pointerenter'],\r\n    [MOUSEDOWN, '_pointerdown'],\r\n    [MOUSEMOVE, '_pointermove'],\r\n    [MOUSEUP, '_pointerup'],\r\n    [MOUSELEAVE, '_pointerleave'],\r\n    [TOUCHSTART, '_pointerdown'],\r\n    [TOUCHMOVE, '_pointermove'],\r\n    [TOUCHEND, '_pointerup'],\r\n    [TOUCHCANCEL, '_pointercancel'],\r\n    [MOUSEOVER, '_pointerover'],\r\n    [WHEEL, '_wheel'],\r\n    [CONTEXTMENU, '_contextmenu'],\r\n    [POINTERDOWN, '_pointerdown'],\r\n    [POINTERMOVE, '_pointermove'],\r\n    [POINTERUP, '_pointerup'],\r\n    [POINTERCANCEL, '_pointercancel'],\r\n    [POINTERLEAVE, '_pointerleave'],\r\n    [LOSTPOINTERCAPTURE, '_lostpointercapture'],\r\n];\r\nconst EVENTS_MAP = {\r\n    mouse: {\r\n        [POINTEROUT]: MOUSEOUT,\r\n        [POINTERLEAVE]: MOUSELEAVE,\r\n        [POINTEROVER]: MOUSEOVER,\r\n        [POINTERENTER]: MOUSEENTER,\r\n        [POINTERMOVE]: MOUSEMOVE,\r\n        [POINTERDOWN]: MOUSEDOWN,\r\n        [POINTERUP]: MOUSEUP,\r\n        [POINTERCANCEL]: 'mousecancel',\r\n        pointerclick: 'click',\r\n        pointerdblclick: 'dblclick',\r\n    },\r\n    touch: {\r\n        [POINTEROUT]: 'touchout',\r\n        [POINTERLEAVE]: 'touchleave',\r\n        [POINTEROVER]: 'touchover',\r\n        [POINTERENTER]: 'touchenter',\r\n        [POINTERMOVE]: TOUCHMOVE,\r\n        [POINTERDOWN]: TOUCHSTART,\r\n        [POINTERUP]: TOUCHEND,\r\n        [POINTERCANCEL]: TOUCHCANCEL,\r\n        pointerclick: 'tap',\r\n        pointerdblclick: 'dbltap',\r\n    },\r\n    pointer: {\r\n        [POINTEROUT]: POINTEROUT,\r\n        [POINTERLEAVE]: POINTERLEAVE,\r\n        [POINTEROVER]: POINTEROVER,\r\n        [POINTERENTER]: POINTERENTER,\r\n        [POINTERMOVE]: POINTERMOVE,\r\n        [POINTERDOWN]: POINTERDOWN,\r\n        [POINTERUP]: POINTERUP,\r\n        [POINTERCANCEL]: POINTERCANCEL,\r\n        pointerclick: 'pointerclick',\r\n        pointerdblclick: 'pointerdblclick',\r\n    },\r\n};\r\nconst getEventType = (type) => {\r\n    if (type.indexOf('pointer') >= 0) {\r\n        return 'pointer';\r\n    }\r\n    if (type.indexOf('touch') >= 0) {\r\n        return 'touch';\r\n    }\r\n    return 'mouse';\r\n};\r\nconst getEventsMap = (eventType) => {\r\n    const type = getEventType(eventType);\r\n    if (type === 'pointer') {\r\n        return Konva.pointerEventsEnabled && EVENTS_MAP.pointer;\r\n    }\r\n    if (type === 'touch') {\r\n        return EVENTS_MAP.touch;\r\n    }\r\n    if (type === 'mouse') {\r\n        return EVENTS_MAP.mouse;\r\n    }\r\n};\r\nfunction checkNoClip(attrs = {}) {\r\n    if (attrs.clipFunc || attrs.clipWidth || attrs.clipHeight) {\r\n        Util.warn('Stage does not support clipping. Please use clip for Layers or Groups.');\r\n    }\r\n    return attrs;\r\n}\r\nconst NO_POINTERS_MESSAGE = `Pointer position is missing and not registered by the stage. Looks like it is outside of the stage container. You can set it manually from event: stage.setPointersPositions(event);`;\r\nexport const stages = [];\r\nexport class Stage extends Container {\r\n    constructor(config) {\r\n        super(checkNoClip(config));\r\n        this._pointerPositions = [];\r\n        this._changedPointerPositions = [];\r\n        this._buildDOM();\r\n        this._bindContentEvents();\r\n        stages.push(this);\r\n        this.on('widthChange.konva heightChange.konva', this._resizeDOM);\r\n        this.on('visibleChange.konva', this._checkVisibility);\r\n        this.on('clipWidthChange.konva clipHeightChange.konva clipFuncChange.konva', () => {\r\n            checkNoClip(this.attrs);\r\n        });\r\n        this._checkVisibility();\r\n    }\r\n    _validateAdd(child) {\r\n        const isLayer = child.getType() === 'Layer';\r\n        const isFastLayer = child.getType() === 'FastLayer';\r\n        const valid = isLayer || isFastLayer;\r\n        if (!valid) {\r\n            Util.throw('You may only add layers to the stage.');\r\n        }\r\n    }\r\n    _checkVisibility() {\r\n        if (!this.content) {\r\n            return;\r\n        }\r\n        const style = this.visible() ? '' : 'none';\r\n        this.content.style.display = style;\r\n    }\r\n    setContainer(container) {\r\n        if (typeof container === STRING) {\r\n            let id;\r\n            if (container.charAt(0) === '.') {\r\n                const className = container.slice(1);\r\n                container = document.getElementsByClassName(className)[0];\r\n            }\r\n            else {\r\n                if (container.charAt(0) !== '#') {\r\n                    id = container;\r\n                }\r\n                else {\r\n                    id = container.slice(1);\r\n                }\r\n                container = document.getElementById(id);\r\n            }\r\n            if (!container) {\r\n                throw 'Can not find container in document with id ' + id;\r\n            }\r\n        }\r\n        this._setAttr('container', container);\r\n        if (this.content) {\r\n            if (this.content.parentElement) {\r\n                this.content.parentElement.removeChild(this.content);\r\n            }\r\n            container.appendChild(this.content);\r\n        }\r\n        return this;\r\n    }\r\n    shouldDrawHit() {\r\n        return true;\r\n    }\r\n    clear() {\r\n        const layers = this.children, len = layers.length;\r\n        for (let n = 0; n < len; n++) {\r\n            layers[n].clear();\r\n        }\r\n        return this;\r\n    }\r\n    clone(obj) {\r\n        if (!obj) {\r\n            obj = {};\r\n        }\r\n        obj.container =\r\n            typeof document !== 'undefined' && document.createElement('div');\r\n        return Container.prototype.clone.call(this, obj);\r\n    }\r\n    destroy() {\r\n        super.destroy();\r\n        const content = this.content;\r\n        if (content && Util._isInDocument(content)) {\r\n            this.container().removeChild(content);\r\n        }\r\n        const index = stages.indexOf(this);\r\n        if (index > -1) {\r\n            stages.splice(index, 1);\r\n        }\r\n        Util.releaseCanvas(this.bufferCanvas._canvas, this.bufferHitCanvas._canvas);\r\n        return this;\r\n    }\r\n    getPointerPosition() {\r\n        const pos = this._pointerPositions[0] || this._changedPointerPositions[0];\r\n        if (!pos) {\r\n            Util.warn(NO_POINTERS_MESSAGE);\r\n            return null;\r\n        }\r\n        return {\r\n            x: pos.x,\r\n            y: pos.y,\r\n        };\r\n    }\r\n    _getPointerById(id) {\r\n        return this._pointerPositions.find((p) => p.id === id);\r\n    }\r\n    getPointersPositions() {\r\n        return this._pointerPositions;\r\n    }\r\n    getStage() {\r\n        return this;\r\n    }\r\n    getContent() {\r\n        return this.content;\r\n    }\r\n    _toKonvaCanvas(config) {\r\n        config = { ...config };\r\n        config.x = config.x || 0;\r\n        config.y = config.y || 0;\r\n        config.width = config.width || this.width();\r\n        config.height = config.height || this.height();\r\n        const canvas = new SceneCanvas({\r\n            width: config.width,\r\n            height: config.height,\r\n            pixelRatio: config.pixelRatio || 1,\r\n        });\r\n        const _context = canvas.getContext()._context;\r\n        const layers = this.children;\r\n        if (config.x || config.y) {\r\n            _context.translate(-1 * config.x, -1 * config.y);\r\n        }\r\n        layers.forEach(function (layer) {\r\n            if (!layer.isVisible()) {\r\n                return;\r\n            }\r\n            const layerCanvas = layer._toKonvaCanvas(config);\r\n            _context.drawImage(layerCanvas._canvas, config.x, config.y, layerCanvas.getWidth() / layerCanvas.getPixelRatio(), layerCanvas.getHeight() / layerCanvas.getPixelRatio());\r\n        });\r\n        return canvas;\r\n    }\r\n    getIntersection(pos) {\r\n        if (!pos) {\r\n            return null;\r\n        }\r\n        const layers = this.children, len = layers.length, end = len - 1;\r\n        for (let n = end; n >= 0; n--) {\r\n            const shape = layers[n].getIntersection(pos);\r\n            if (shape) {\r\n                return shape;\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n    _resizeDOM() {\r\n        const width = this.width();\r\n        const height = this.height();\r\n        if (this.content) {\r\n            this.content.style.width = width + PX;\r\n            this.content.style.height = height + PX;\r\n        }\r\n        this.bufferCanvas.setSize(width, height);\r\n        this.bufferHitCanvas.setSize(width, height);\r\n        this.children.forEach((layer) => {\r\n            layer.setSize({ width, height });\r\n            layer.draw();\r\n        });\r\n    }\r\n    add(layer, ...rest) {\r\n        if (arguments.length > 1) {\r\n            for (let i = 0; i < arguments.length; i++) {\r\n                this.add(arguments[i]);\r\n            }\r\n            return this;\r\n        }\r\n        super.add(layer);\r\n        const length = this.children.length;\r\n        if (length > MAX_LAYERS_NUMBER) {\r\n            Util.warn('The stage has ' +\r\n                length +\r\n                ' layers. Recommended maximum number of layers is 3-5. Adding more layers into the stage may drop the performance. Rethink your tree structure, you can use Konva.Group.');\r\n        }\r\n        layer.setSize({ width: this.width(), height: this.height() });\r\n        layer.draw();\r\n        if (Konva.isBrowser) {\r\n            this.content.appendChild(layer.canvas._canvas);\r\n        }\r\n        return this;\r\n    }\r\n    getParent() {\r\n        return null;\r\n    }\r\n    getLayer() {\r\n        return null;\r\n    }\r\n    hasPointerCapture(pointerId) {\r\n        return PointerEvents.hasPointerCapture(pointerId, this);\r\n    }\r\n    setPointerCapture(pointerId) {\r\n        PointerEvents.setPointerCapture(pointerId, this);\r\n    }\r\n    releaseCapture(pointerId) {\r\n        PointerEvents.releaseCapture(pointerId, this);\r\n    }\r\n    getLayers() {\r\n        return this.children;\r\n    }\r\n    _bindContentEvents() {\r\n        if (!Konva.isBrowser) {\r\n            return;\r\n        }\r\n        EVENTS.forEach(([event, methodName]) => {\r\n            this.content.addEventListener(event, (evt) => {\r\n                this[methodName](evt);\r\n            }, { passive: false });\r\n        });\r\n    }\r\n    _pointerenter(evt) {\r\n        this.setPointersPositions(evt);\r\n        const events = getEventsMap(evt.type);\r\n        if (events) {\r\n            this._fire(events.pointerenter, {\r\n                evt: evt,\r\n                target: this,\r\n                currentTarget: this,\r\n            });\r\n        }\r\n    }\r\n    _pointerover(evt) {\r\n        this.setPointersPositions(evt);\r\n        const events = getEventsMap(evt.type);\r\n        if (events) {\r\n            this._fire(events.pointerover, {\r\n                evt: evt,\r\n                target: this,\r\n                currentTarget: this,\r\n            });\r\n        }\r\n    }\r\n    _getTargetShape(evenType) {\r\n        let shape = this[evenType + 'targetShape'];\r\n        if (shape && !shape.getStage()) {\r\n            shape = null;\r\n        }\r\n        return shape;\r\n    }\r\n    _pointerleave(evt) {\r\n        const events = getEventsMap(evt.type);\r\n        const eventType = getEventType(evt.type);\r\n        if (!events) {\r\n            return;\r\n        }\r\n        this.setPointersPositions(evt);\r\n        const targetShape = this._getTargetShape(eventType);\r\n        const eventsEnabled = !(Konva.isDragging() || Konva.isTransforming()) || Konva.hitOnDragEnabled;\r\n        if (targetShape && eventsEnabled) {\r\n            targetShape._fireAndBubble(events.pointerout, { evt: evt });\r\n            targetShape._fireAndBubble(events.pointerleave, { evt: evt });\r\n            this._fire(events.pointerleave, {\r\n                evt: evt,\r\n                target: this,\r\n                currentTarget: this,\r\n            });\r\n            this[eventType + 'targetShape'] = null;\r\n        }\r\n        else if (eventsEnabled) {\r\n            this._fire(events.pointerleave, {\r\n                evt: evt,\r\n                target: this,\r\n                currentTarget: this,\r\n            });\r\n            this._fire(events.pointerout, {\r\n                evt: evt,\r\n                target: this,\r\n                currentTarget: this,\r\n            });\r\n        }\r\n        this.pointerPos = null;\r\n        this._pointerPositions = [];\r\n    }\r\n    _pointerdown(evt) {\r\n        const events = getEventsMap(evt.type);\r\n        const eventType = getEventType(evt.type);\r\n        if (!events) {\r\n            return;\r\n        }\r\n        this.setPointersPositions(evt);\r\n        let triggeredOnShape = false;\r\n        this._changedPointerPositions.forEach((pos) => {\r\n            const shape = this.getIntersection(pos);\r\n            DD.justDragged = false;\r\n            Konva['_' + eventType + 'ListenClick'] = true;\r\n            if (!shape || !shape.isListening()) {\r\n                this[eventType + 'ClickStartShape'] = undefined;\r\n                return;\r\n            }\r\n            if (Konva.capturePointerEventsEnabled) {\r\n                shape.setPointerCapture(pos.id);\r\n            }\r\n            this[eventType + 'ClickStartShape'] = shape;\r\n            shape._fireAndBubble(events.pointerdown, {\r\n                evt: evt,\r\n                pointerId: pos.id,\r\n            });\r\n            triggeredOnShape = true;\r\n            const isTouch = evt.type.indexOf('touch') >= 0;\r\n            if (shape.preventDefault() && evt.cancelable && isTouch) {\r\n                evt.preventDefault();\r\n            }\r\n        });\r\n        if (!triggeredOnShape) {\r\n            this._fire(events.pointerdown, {\r\n                evt: evt,\r\n                target: this,\r\n                currentTarget: this,\r\n                pointerId: this._pointerPositions[0].id,\r\n            });\r\n        }\r\n    }\r\n    _pointermove(evt) {\r\n        const events = getEventsMap(evt.type);\r\n        const eventType = getEventType(evt.type);\r\n        if (!events) {\r\n            return;\r\n        }\r\n        const isTouchPointer = evt.type.indexOf('touch') >= 0 ||\r\n            evt.pointerType === 'touch';\r\n        if (Konva.isDragging() &&\r\n            DD.node.preventDefault() &&\r\n            evt.cancelable &&\r\n            isTouchPointer) {\r\n            evt.preventDefault();\r\n        }\r\n        this.setPointersPositions(evt);\r\n        const eventsEnabled = !(Konva.isDragging() || Konva.isTransforming()) || Konva.hitOnDragEnabled;\r\n        if (!eventsEnabled) {\r\n            return;\r\n        }\r\n        const processedShapesIds = {};\r\n        let triggeredOnShape = false;\r\n        const targetShape = this._getTargetShape(eventType);\r\n        this._changedPointerPositions.forEach((pos) => {\r\n            const shape = (PointerEvents.getCapturedShape(pos.id) ||\r\n                this.getIntersection(pos));\r\n            const pointerId = pos.id;\r\n            const event = { evt: evt, pointerId };\r\n            const differentTarget = targetShape !== shape;\r\n            if (differentTarget && targetShape) {\r\n                targetShape._fireAndBubble(events.pointerout, { ...event }, shape);\r\n                targetShape._fireAndBubble(events.pointerleave, { ...event }, shape);\r\n            }\r\n            if (shape) {\r\n                if (processedShapesIds[shape._id]) {\r\n                    return;\r\n                }\r\n                processedShapesIds[shape._id] = true;\r\n            }\r\n            if (shape && shape.isListening()) {\r\n                triggeredOnShape = true;\r\n                if (differentTarget) {\r\n                    shape._fireAndBubble(events.pointerover, { ...event }, targetShape);\r\n                    shape._fireAndBubble(events.pointerenter, { ...event }, targetShape);\r\n                    this[eventType + 'targetShape'] = shape;\r\n                }\r\n                shape._fireAndBubble(events.pointermove, { ...event });\r\n            }\r\n            else {\r\n                if (targetShape) {\r\n                    this._fire(events.pointerover, {\r\n                        evt: evt,\r\n                        target: this,\r\n                        currentTarget: this,\r\n                        pointerId,\r\n                    });\r\n                    this[eventType + 'targetShape'] = null;\r\n                }\r\n            }\r\n        });\r\n        if (!triggeredOnShape) {\r\n            this._fire(events.pointermove, {\r\n                evt: evt,\r\n                target: this,\r\n                currentTarget: this,\r\n                pointerId: this._changedPointerPositions[0].id,\r\n            });\r\n        }\r\n    }\r\n    _pointerup(evt) {\r\n        const events = getEventsMap(evt.type);\r\n        const eventType = getEventType(evt.type);\r\n        if (!events) {\r\n            return;\r\n        }\r\n        this.setPointersPositions(evt);\r\n        const clickStartShape = this[eventType + 'ClickStartShape'];\r\n        const clickEndShape = this[eventType + 'ClickEndShape'];\r\n        const processedShapesIds = {};\r\n        let skipPointerUpTrigger = false;\r\n        this._changedPointerPositions.forEach((pos) => {\r\n            const shape = (PointerEvents.getCapturedShape(pos.id) ||\r\n                this.getIntersection(pos));\r\n            if (shape) {\r\n                shape.releaseCapture(pos.id);\r\n                if (processedShapesIds[shape._id]) {\r\n                    return;\r\n                }\r\n                processedShapesIds[shape._id] = true;\r\n            }\r\n            const pointerId = pos.id;\r\n            const event = { evt: evt, pointerId };\r\n            let fireDblClick = false;\r\n            if (Konva['_' + eventType + 'InDblClickWindow']) {\r\n                fireDblClick = true;\r\n                clearTimeout(this[eventType + 'DblTimeout']);\r\n            }\r\n            else if (!DD.justDragged) {\r\n                Konva['_' + eventType + 'InDblClickWindow'] = true;\r\n                clearTimeout(this[eventType + 'DblTimeout']);\r\n            }\r\n            this[eventType + 'DblTimeout'] = setTimeout(function () {\r\n                Konva['_' + eventType + 'InDblClickWindow'] = false;\r\n            }, Konva.dblClickWindow);\r\n            if (shape && shape.isListening()) {\r\n                skipPointerUpTrigger = true;\r\n                this[eventType + 'ClickEndShape'] = shape;\r\n                shape._fireAndBubble(events.pointerup, { ...event });\r\n                if (Konva['_' + eventType + 'ListenClick'] &&\r\n                    clickStartShape &&\r\n                    clickStartShape === shape) {\r\n                    shape._fireAndBubble(events.pointerclick, { ...event });\r\n                    if (fireDblClick && clickEndShape && clickEndShape === shape) {\r\n                        shape._fireAndBubble(events.pointerdblclick, { ...event });\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                this[eventType + 'ClickEndShape'] = null;\r\n                if (!skipPointerUpTrigger) {\r\n                    this._fire(events.pointerup, {\r\n                        evt: evt,\r\n                        target: this,\r\n                        currentTarget: this,\r\n                        pointerId: this._changedPointerPositions[0].id,\r\n                    });\r\n                    skipPointerUpTrigger = true;\r\n                }\r\n                if (Konva['_' + eventType + 'ListenClick']) {\r\n                    this._fire(events.pointerclick, {\r\n                        evt: evt,\r\n                        target: this,\r\n                        currentTarget: this,\r\n                        pointerId,\r\n                    });\r\n                }\r\n                if (fireDblClick) {\r\n                    this._fire(events.pointerdblclick, {\r\n                        evt: evt,\r\n                        target: this,\r\n                        currentTarget: this,\r\n                        pointerId,\r\n                    });\r\n                }\r\n            }\r\n        });\r\n        if (!skipPointerUpTrigger) {\r\n            this._fire(events.pointerup, {\r\n                evt: evt,\r\n                target: this,\r\n                currentTarget: this,\r\n                pointerId: this._changedPointerPositions[0].id,\r\n            });\r\n        }\r\n        Konva['_' + eventType + 'ListenClick'] = false;\r\n        if (evt.cancelable && eventType !== 'touch' && eventType !== 'pointer') {\r\n            evt.preventDefault();\r\n        }\r\n    }\r\n    _contextmenu(evt) {\r\n        this.setPointersPositions(evt);\r\n        const shape = this.getIntersection(this.getPointerPosition());\r\n        if (shape && shape.isListening()) {\r\n            shape._fireAndBubble(CONTEXTMENU, { evt: evt });\r\n        }\r\n        else {\r\n            this._fire(CONTEXTMENU, {\r\n                evt: evt,\r\n                target: this,\r\n                currentTarget: this,\r\n            });\r\n        }\r\n    }\r\n    _wheel(evt) {\r\n        this.setPointersPositions(evt);\r\n        const shape = this.getIntersection(this.getPointerPosition());\r\n        if (shape && shape.isListening()) {\r\n            shape._fireAndBubble(WHEEL, { evt: evt });\r\n        }\r\n        else {\r\n            this._fire(WHEEL, {\r\n                evt: evt,\r\n                target: this,\r\n                currentTarget: this,\r\n            });\r\n        }\r\n    }\r\n    _pointercancel(evt) {\r\n        this.setPointersPositions(evt);\r\n        const shape = PointerEvents.getCapturedShape(evt.pointerId) ||\r\n            this.getIntersection(this.getPointerPosition());\r\n        if (shape) {\r\n            shape._fireAndBubble(POINTERUP, PointerEvents.createEvent(evt));\r\n        }\r\n        PointerEvents.releaseCapture(evt.pointerId);\r\n    }\r\n    _lostpointercapture(evt) {\r\n        PointerEvents.releaseCapture(evt.pointerId);\r\n    }\r\n    setPointersPositions(evt) {\r\n        const contentPosition = this._getContentPosition();\r\n        let x = null, y = null;\r\n        evt = evt ? evt : window.event;\r\n        if (evt.touches !== undefined) {\r\n            this._pointerPositions = [];\r\n            this._changedPointerPositions = [];\r\n            Array.prototype.forEach.call(evt.touches, (touch) => {\r\n                this._pointerPositions.push({\r\n                    id: touch.identifier,\r\n                    x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\r\n                    y: (touch.clientY - contentPosition.top) / contentPosition.scaleY,\r\n                });\r\n            });\r\n            Array.prototype.forEach.call(evt.changedTouches || evt.touches, (touch) => {\r\n                this._changedPointerPositions.push({\r\n                    id: touch.identifier,\r\n                    x: (touch.clientX - contentPosition.left) / contentPosition.scaleX,\r\n                    y: (touch.clientY - contentPosition.top) / contentPosition.scaleY,\r\n                });\r\n            });\r\n        }\r\n        else {\r\n            x = (evt.clientX - contentPosition.left) / contentPosition.scaleX;\r\n            y = (evt.clientY - contentPosition.top) / contentPosition.scaleY;\r\n            this.pointerPos = {\r\n                x: x,\r\n                y: y,\r\n            };\r\n            this._pointerPositions = [{ x, y, id: Util._getFirstPointerId(evt) }];\r\n            this._changedPointerPositions = [\r\n                { x, y, id: Util._getFirstPointerId(evt) },\r\n            ];\r\n        }\r\n    }\r\n    _setPointerPosition(evt) {\r\n        Util.warn('Method _setPointerPosition is deprecated. Use \"stage.setPointersPositions(event)\" instead.');\r\n        this.setPointersPositions(evt);\r\n    }\r\n    _getContentPosition() {\r\n        if (!this.content || !this.content.getBoundingClientRect) {\r\n            return {\r\n                top: 0,\r\n                left: 0,\r\n                scaleX: 1,\r\n                scaleY: 1,\r\n            };\r\n        }\r\n        const rect = this.content.getBoundingClientRect();\r\n        return {\r\n            top: rect.top,\r\n            left: rect.left,\r\n            scaleX: rect.width / this.content.clientWidth || 1,\r\n            scaleY: rect.height / this.content.clientHeight || 1,\r\n        };\r\n    }\r\n    _buildDOM() {\r\n        this.bufferCanvas = new SceneCanvas({\r\n            width: this.width(),\r\n            height: this.height(),\r\n        });\r\n        this.bufferHitCanvas = new HitCanvas({\r\n            pixelRatio: 1,\r\n            width: this.width(),\r\n            height: this.height(),\r\n        });\r\n        if (!Konva.isBrowser) {\r\n            return;\r\n        }\r\n        const container = this.container();\r\n        if (!container) {\r\n            throw 'Stage has no container. A container is required.';\r\n        }\r\n        container.innerHTML = '';\r\n        this.content = document.createElement('div');\r\n        this.content.style.position = 'relative';\r\n        this.content.style.userSelect = 'none';\r\n        this.content.className = 'konvajs-content';\r\n        this.content.setAttribute('role', 'presentation');\r\n        container.appendChild(this.content);\r\n        this._resizeDOM();\r\n    }\r\n    cache() {\r\n        Util.warn('Cache function is not allowed for stage. You may use cache only for layers, groups and shapes.');\r\n        return this;\r\n    }\r\n    clearCache() {\r\n        return this;\r\n    }\r\n    batchDraw() {\r\n        this.getChildren().forEach(function (layer) {\r\n            layer.batchDraw();\r\n        });\r\n        return this;\r\n    }\r\n}\r\nStage.prototype.nodeType = STAGE;\r\n_registerNode(Stage);\r\nFactory.addGetterSetter(Stage, 'container');\r\nif (Konva.isBrowser) {\r\n    document.addEventListener('visibilitychange', () => {\r\n        stages.forEach((stage) => {\r\n            stage.batchDraw();\r\n        });\r\n    });\r\n}\r\n"],"mappings":"AAAA,SAASA,IAAI,QAAQ,WAAW;AAChC,SAASC,OAAO,QAAQ,cAAc;AACtC,SAASC,SAAS,QAAQ,gBAAgB;AAC1C,SAASC,KAAK,QAAQ,aAAa;AACnC,SAASC,WAAW,EAAEC,SAAS,QAAQ,aAAa;AACpD,SAASC,EAAE,QAAQ,kBAAkB;AACrC,SAASC,aAAa,QAAQ,aAAa;AAC3C,OAAO,KAAKC,aAAa,MAAM,oBAAoB;AACnD,MAAMC,KAAK,GAAG,OAAO;EAAEC,MAAM,GAAG,QAAQ;EAAEC,EAAE,GAAG,IAAI;EAAEC,QAAQ,GAAG,UAAU;EAAEC,UAAU,GAAG,YAAY;EAAEC,SAAS,GAAG,WAAW;EAAEC,UAAU,GAAG,YAAY;EAAEC,SAAS,GAAG,WAAW;EAAEC,SAAS,GAAG,WAAW;EAAEC,OAAO,GAAG,SAAS;EAAEC,WAAW,GAAG,aAAa;EAAEC,WAAW,GAAG,aAAa;EAAEC,SAAS,GAAG,WAAW;EAAEC,aAAa,GAAG,eAAe;EAAEC,kBAAkB,GAAG,oBAAoB;EAAEC,UAAU,GAAG,YAAY;EAAEC,YAAY,GAAG,cAAc;EAAEC,WAAW,GAAG,aAAa;EAAEC,YAAY,GAAG,cAAc;EAAEC,WAAW,GAAG,aAAa;EAAEC,UAAU,GAAG,YAAY;EAAEC,QAAQ,GAAG,UAAU;EAAEC,SAAS,GAAG,WAAW;EAAEC,WAAW,GAAG,aAAa;EAAEC,KAAK,GAAG,OAAO;EAAEC,iBAAiB,GAAG,CAAC;EAAEC,MAAM,GAAG,CACzqB,CAACpB,UAAU,EAAE,eAAe,CAAC,EAC7B,CAACE,SAAS,EAAE,cAAc,CAAC,EAC3B,CAACD,SAAS,EAAE,cAAc,CAAC,EAC3B,CAACE,OAAO,EAAE,YAAY,CAAC,EACvB,CAACL,UAAU,EAAE,eAAe,CAAC,EAC7B,CAACgB,UAAU,EAAE,cAAc,CAAC,EAC5B,CAACE,SAAS,EAAE,cAAc,CAAC,EAC3B,CAACD,QAAQ,EAAE,YAAY,CAAC,EACxB,CAACE,WAAW,EAAE,gBAAgB,CAAC,EAC/B,CAAClB,SAAS,EAAE,cAAc,CAAC,EAC3B,CAACmB,KAAK,EAAE,QAAQ,CAAC,EACjB,CAACL,WAAW,EAAE,cAAc,CAAC,EAC7B,CAACR,WAAW,EAAE,cAAc,CAAC,EAC7B,CAACD,WAAW,EAAE,cAAc,CAAC,EAC7B,CAACE,SAAS,EAAE,YAAY,CAAC,EACzB,CAACC,aAAa,EAAE,gBAAgB,CAAC,EACjC,CAACG,YAAY,EAAE,eAAe,CAAC,EAC/B,CAACF,kBAAkB,EAAE,qBAAqB,CAAC,CAC9C;AACD,MAAMa,UAAU,GAAG;EACfC,KAAK,EAAE;IACH,CAACb,UAAU,GAAGZ,QAAQ;IACtB,CAACa,YAAY,GAAGZ,UAAU;IAC1B,CAACa,WAAW,GAAGZ,SAAS;IACxB,CAACa,YAAY,GAAGZ,UAAU;IAC1B,CAACI,WAAW,GAAGH,SAAS;IACxB,CAACI,WAAW,GAAGH,SAAS;IACxB,CAACI,SAAS,GAAGH,OAAO;IACpB,CAACI,aAAa,GAAG,aAAa;IAC9BgB,YAAY,EAAE,OAAO;IACrBC,eAAe,EAAE;EACrB,CAAC;EACDC,KAAK,EAAE;IACH,CAAChB,UAAU,GAAG,UAAU;IACxB,CAACC,YAAY,GAAG,YAAY;IAC5B,CAACC,WAAW,GAAG,WAAW;IAC1B,CAACC,YAAY,GAAG,YAAY;IAC5B,CAACR,WAAW,GAAGY,SAAS;IACxB,CAACX,WAAW,GAAGS,UAAU;IACzB,CAACR,SAAS,GAAGS,QAAQ;IACrB,CAACR,aAAa,GAAGU,WAAW;IAC5BM,YAAY,EAAE,KAAK;IACnBC,eAAe,EAAE;EACrB,CAAC;EACDE,OAAO,EAAE;IACL,CAACjB,UAAU,GAAGA,UAAU;IACxB,CAACC,YAAY,GAAGA,YAAY;IAC5B,CAACC,WAAW,GAAGA,WAAW;IAC1B,CAACC,YAAY,GAAGA,YAAY;IAC5B,CAACR,WAAW,GAAGA,WAAW;IAC1B,CAACC,WAAW,GAAGA,WAAW;IAC1B,CAACC,SAAS,GAAGA,SAAS;IACtB,CAACC,aAAa,GAAGA,aAAa;IAC9BgB,YAAY,EAAE,cAAc;IAC5BC,eAAe,EAAE;EACrB;AACJ,CAAC;AACD,MAAMG,YAAY,GAAIC,IAAI,IAAK;EAC3B,IAAIA,IAAI,CAACC,OAAO,CAAC,SAAS,CAAC,IAAI,CAAC,EAAE;IAC9B,OAAO,SAAS;EACpB;EACA,IAAID,IAAI,CAACC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;IAC5B,OAAO,OAAO;EAClB;EACA,OAAO,OAAO;AAClB,CAAC;AACD,MAAMC,YAAY,GAAIC,SAAS,IAAK;EAChC,MAAMH,IAAI,GAAGD,YAAY,CAACI,SAAS,CAAC;EACpC,IAAIH,IAAI,KAAK,SAAS,EAAE;IACpB,OAAOxC,KAAK,CAAC4C,oBAAoB,IAAIX,UAAU,CAACK,OAAO;EAC3D;EACA,IAAIE,IAAI,KAAK,OAAO,EAAE;IAClB,OAAOP,UAAU,CAACI,KAAK;EAC3B;EACA,IAAIG,IAAI,KAAK,OAAO,EAAE;IAClB,OAAOP,UAAU,CAACC,KAAK;EAC3B;AACJ,CAAC;AACD,SAASW,WAAWA,CAACC,KAAK,GAAG,CAAC,CAAC,EAAE;EAC7B,IAAIA,KAAK,CAACC,QAAQ,IAAID,KAAK,CAACE,SAAS,IAAIF,KAAK,CAACG,UAAU,EAAE;IACvDpD,IAAI,CAACqD,IAAI,CAAC,wEAAwE,CAAC;EACvF;EACA,OAAOJ,KAAK;AAChB;AACA,MAAMK,mBAAmB,GAAG,sLAAsL;AAClN,OAAO,MAAMC,MAAM,GAAG,EAAE;AACxB,OAAO,MAAMC,KAAK,SAAStD,SAAS,CAAC;EACjCuD,WAAWA,CAACC,MAAM,EAAE;IAChB,KAAK,CAACV,WAAW,CAACU,MAAM,CAAC,CAAC;IAC1B,IAAI,CAACC,iBAAiB,GAAG,EAAE;IAC3B,IAAI,CAACC,wBAAwB,GAAG,EAAE;IAClC,IAAI,CAACC,SAAS,CAAC,CAAC;IAChB,IAAI,CAACC,kBAAkB,CAAC,CAAC;IACzBP,MAAM,CAACQ,IAAI,CAAC,IAAI,CAAC;IACjB,IAAI,CAACC,EAAE,CAAC,sCAAsC,EAAE,IAAI,CAACC,UAAU,CAAC;IAChE,IAAI,CAACD,EAAE,CAAC,qBAAqB,EAAE,IAAI,CAACE,gBAAgB,CAAC;IACrD,IAAI,CAACF,EAAE,CAAC,mEAAmE,EAAE,MAAM;MAC/EhB,WAAW,CAAC,IAAI,CAACC,KAAK,CAAC;IAC3B,CAAC,CAAC;IACF,IAAI,CAACiB,gBAAgB,CAAC,CAAC;EAC3B;EACAC,YAAYA,CAACC,KAAK,EAAE;IAChB,MAAMC,OAAO,GAAGD,KAAK,CAACE,OAAO,CAAC,CAAC,KAAK,OAAO;IAC3C,MAAMC,WAAW,GAAGH,KAAK,CAACE,OAAO,CAAC,CAAC,KAAK,WAAW;IACnD,MAAME,KAAK,GAAGH,OAAO,IAAIE,WAAW;IACpC,IAAI,CAACC,KAAK,EAAE;MACRxE,IAAI,CAACyE,KAAK,CAAC,uCAAuC,CAAC;IACvD;EACJ;EACAP,gBAAgBA,CAAA,EAAG;IACf,IAAI,CAAC,IAAI,CAACQ,OAAO,EAAE;MACf;IACJ;IACA,MAAMC,KAAK,GAAG,IAAI,CAACC,OAAO,CAAC,CAAC,GAAG,EAAE,GAAG,MAAM;IAC1C,IAAI,CAACF,OAAO,CAACC,KAAK,CAACE,OAAO,GAAGF,KAAK;EACtC;EACAG,YAAYA,CAACC,SAAS,EAAE;IACpB,IAAI,OAAOA,SAAS,KAAKrE,MAAM,EAAE;MAC7B,IAAIsE,EAAE;MACN,IAAID,SAAS,CAACE,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;QAC7B,MAAMC,SAAS,GAAGH,SAAS,CAACI,KAAK,CAAC,CAAC,CAAC;QACpCJ,SAAS,GAAGK,QAAQ,CAACC,sBAAsB,CAACH,SAAS,CAAC,CAAC,CAAC,CAAC;MAC7D,CAAC,MACI;QACD,IAAIH,SAAS,CAACE,MAAM,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE;UAC7BD,EAAE,GAAGD,SAAS;QAClB,CAAC,MACI;UACDC,EAAE,GAAGD,SAAS,CAACI,KAAK,CAAC,CAAC,CAAC;QAC3B;QACAJ,SAAS,GAAGK,QAAQ,CAACE,cAAc,CAACN,EAAE,CAAC;MAC3C;MACA,IAAI,CAACD,SAAS,EAAE;QACZ,MAAM,6CAA6C,GAAGC,EAAE;MAC5D;IACJ;IACA,IAAI,CAACO,QAAQ,CAAC,WAAW,EAAER,SAAS,CAAC;IACrC,IAAI,IAAI,CAACL,OAAO,EAAE;MACd,IAAI,IAAI,CAACA,OAAO,CAACc,aAAa,EAAE;QAC5B,IAAI,CAACd,OAAO,CAACc,aAAa,CAACC,WAAW,CAAC,IAAI,CAACf,OAAO,CAAC;MACxD;MACAK,SAAS,CAACW,WAAW,CAAC,IAAI,CAAChB,OAAO,CAAC;IACvC;IACA,OAAO,IAAI;EACf;EACAiB,aAAaA,CAAA,EAAG;IACZ,OAAO,IAAI;EACf;EACAC,KAAKA,CAAA,EAAG;IACJ,MAAMC,MAAM,GAAG,IAAI,CAACC,QAAQ;MAAEC,GAAG,GAAGF,MAAM,CAACG,MAAM;IACjD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,GAAG,EAAEE,CAAC,EAAE,EAAE;MAC1BJ,MAAM,CAACI,CAAC,CAAC,CAACL,KAAK,CAAC,CAAC;IACrB;IACA,OAAO,IAAI;EACf;EACAM,KAAKA,CAACC,GAAG,EAAE;IACP,IAAI,CAACA,GAAG,EAAE;MACNA,GAAG,GAAG,CAAC,CAAC;IACZ;IACAA,GAAG,CAACpB,SAAS,GACT,OAAOK,QAAQ,KAAK,WAAW,IAAIA,QAAQ,CAACgB,aAAa,CAAC,KAAK,CAAC;IACpE,OAAOlG,SAAS,CAACmG,SAAS,CAACH,KAAK,CAACI,IAAI,CAAC,IAAI,EAAEH,GAAG,CAAC;EACpD;EACAI,OAAOA,CAAA,EAAG;IACN,KAAK,CAACA,OAAO,CAAC,CAAC;IACf,MAAM7B,OAAO,GAAG,IAAI,CAACA,OAAO;IAC5B,IAAIA,OAAO,IAAI1E,IAAI,CAACwG,aAAa,CAAC9B,OAAO,CAAC,EAAE;MACxC,IAAI,CAACK,SAAS,CAAC,CAAC,CAACU,WAAW,CAACf,OAAO,CAAC;IACzC;IACA,MAAM+B,KAAK,GAAGlD,MAAM,CAACX,OAAO,CAAC,IAAI,CAAC;IAClC,IAAI6D,KAAK,GAAG,CAAC,CAAC,EAAE;MACZlD,MAAM,CAACmD,MAAM,CAACD,KAAK,EAAE,CAAC,CAAC;IAC3B;IACAzG,IAAI,CAAC2G,aAAa,CAAC,IAAI,CAACC,YAAY,CAACC,OAAO,EAAE,IAAI,CAACC,eAAe,CAACD,OAAO,CAAC;IAC3E,OAAO,IAAI;EACf;EACAE,kBAAkBA,CAAA,EAAG;IACjB,MAAMC,GAAG,GAAG,IAAI,CAACrD,iBAAiB,CAAC,CAAC,CAAC,IAAI,IAAI,CAACC,wBAAwB,CAAC,CAAC,CAAC;IACzE,IAAI,CAACoD,GAAG,EAAE;MACNhH,IAAI,CAACqD,IAAI,CAACC,mBAAmB,CAAC;MAC9B,OAAO,IAAI;IACf;IACA,OAAO;MACH2D,CAAC,EAAED,GAAG,CAACC,CAAC;MACRC,CAAC,EAAEF,GAAG,CAACE;IACX,CAAC;EACL;EACAC,eAAeA,CAACnC,EAAE,EAAE;IAChB,OAAO,IAAI,CAACrB,iBAAiB,CAACyD,IAAI,CAAEC,CAAC,IAAKA,CAAC,CAACrC,EAAE,KAAKA,EAAE,CAAC;EAC1D;EACAsC,oBAAoBA,CAAA,EAAG;IACnB,OAAO,IAAI,CAAC3D,iBAAiB;EACjC;EACA4D,QAAQA,CAAA,EAAG;IACP,OAAO,IAAI;EACf;EACAC,UAAUA,CAAA,EAAG;IACT,OAAO,IAAI,CAAC9C,OAAO;EACvB;EACA+C,cAAcA,CAAC/D,MAAM,EAAE;IACnBA,MAAM,GAAG;MAAE,GAAGA;IAAO,CAAC;IACtBA,MAAM,CAACuD,CAAC,GAAGvD,MAAM,CAACuD,CAAC,IAAI,CAAC;IACxBvD,MAAM,CAACwD,CAAC,GAAGxD,MAAM,CAACwD,CAAC,IAAI,CAAC;IACxBxD,MAAM,CAACgE,KAAK,GAAGhE,MAAM,CAACgE,KAAK,IAAI,IAAI,CAACA,KAAK,CAAC,CAAC;IAC3ChE,MAAM,CAACiE,MAAM,GAAGjE,MAAM,CAACiE,MAAM,IAAI,IAAI,CAACA,MAAM,CAAC,CAAC;IAC9C,MAAMC,MAAM,GAAG,IAAIxH,WAAW,CAAC;MAC3BsH,KAAK,EAAEhE,MAAM,CAACgE,KAAK;MACnBC,MAAM,EAAEjE,MAAM,CAACiE,MAAM;MACrBE,UAAU,EAAEnE,MAAM,CAACmE,UAAU,IAAI;IACrC,CAAC,CAAC;IACF,MAAMC,QAAQ,GAAGF,MAAM,CAACG,UAAU,CAAC,CAAC,CAACD,QAAQ;IAC7C,MAAMjC,MAAM,GAAG,IAAI,CAACC,QAAQ;IAC5B,IAAIpC,MAAM,CAACuD,CAAC,IAAIvD,MAAM,CAACwD,CAAC,EAAE;MACtBY,QAAQ,CAACE,SAAS,CAAC,CAAC,CAAC,GAAGtE,MAAM,CAACuD,CAAC,EAAE,CAAC,CAAC,GAAGvD,MAAM,CAACwD,CAAC,CAAC;IACpD;IACArB,MAAM,CAACoC,OAAO,CAAC,UAAUC,KAAK,EAAE;MAC5B,IAAI,CAACA,KAAK,CAACC,SAAS,CAAC,CAAC,EAAE;QACpB;MACJ;MACA,MAAMC,WAAW,GAAGF,KAAK,CAACT,cAAc,CAAC/D,MAAM,CAAC;MAChDoE,QAAQ,CAACO,SAAS,CAACD,WAAW,CAACvB,OAAO,EAAEnD,MAAM,CAACuD,CAAC,EAAEvD,MAAM,CAACwD,CAAC,EAAEkB,WAAW,CAACE,QAAQ,CAAC,CAAC,GAAGF,WAAW,CAACG,aAAa,CAAC,CAAC,EAAEH,WAAW,CAACI,SAAS,CAAC,CAAC,GAAGJ,WAAW,CAACG,aAAa,CAAC,CAAC,CAAC;IAC5K,CAAC,CAAC;IACF,OAAOX,MAAM;EACjB;EACAa,eAAeA,CAACzB,GAAG,EAAE;IACjB,IAAI,CAACA,GAAG,EAAE;MACN,OAAO,IAAI;IACf;IACA,MAAMnB,MAAM,GAAG,IAAI,CAACC,QAAQ;MAAEC,GAAG,GAAGF,MAAM,CAACG,MAAM;MAAE0C,GAAG,GAAG3C,GAAG,GAAG,CAAC;IAChE,KAAK,IAAIE,CAAC,GAAGyC,GAAG,EAAEzC,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;MAC3B,MAAM0C,KAAK,GAAG9C,MAAM,CAACI,CAAC,CAAC,CAACwC,eAAe,CAACzB,GAAG,CAAC;MAC5C,IAAI2B,KAAK,EAAE;QACP,OAAOA,KAAK;MAChB;IACJ;IACA,OAAO,IAAI;EACf;EACA1E,UAAUA,CAAA,EAAG;IACT,MAAMyD,KAAK,GAAG,IAAI,CAACA,KAAK,CAAC,CAAC;IAC1B,MAAMC,MAAM,GAAG,IAAI,CAACA,MAAM,CAAC,CAAC;IAC5B,IAAI,IAAI,CAACjD,OAAO,EAAE;MACd,IAAI,CAACA,OAAO,CAACC,KAAK,CAAC+C,KAAK,GAAGA,KAAK,GAAG/G,EAAE;MACrC,IAAI,CAAC+D,OAAO,CAACC,KAAK,CAACgD,MAAM,GAAGA,MAAM,GAAGhH,EAAE;IAC3C;IACA,IAAI,CAACiG,YAAY,CAACgC,OAAO,CAAClB,KAAK,EAAEC,MAAM,CAAC;IACxC,IAAI,CAACb,eAAe,CAAC8B,OAAO,CAAClB,KAAK,EAAEC,MAAM,CAAC;IAC3C,IAAI,CAAC7B,QAAQ,CAACmC,OAAO,CAAEC,KAAK,IAAK;MAC7BA,KAAK,CAACU,OAAO,CAAC;QAAElB,KAAK;QAAEC;MAAO,CAAC,CAAC;MAChCO,KAAK,CAACW,IAAI,CAAC,CAAC;IAChB,CAAC,CAAC;EACN;EACAC,GAAGA,CAACZ,KAAK,EAAE,GAAGa,IAAI,EAAE;IAChB,IAAIC,SAAS,CAAChD,MAAM,GAAG,CAAC,EAAE;MACtB,KAAK,IAAIiD,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGD,SAAS,CAAChD,MAAM,EAAEiD,CAAC,EAAE,EAAE;QACvC,IAAI,CAACH,GAAG,CAACE,SAAS,CAACC,CAAC,CAAC,CAAC;MAC1B;MACA,OAAO,IAAI;IACf;IACA,KAAK,CAACH,GAAG,CAACZ,KAAK,CAAC;IAChB,MAAMlC,MAAM,GAAG,IAAI,CAACF,QAAQ,CAACE,MAAM;IACnC,IAAIA,MAAM,GAAG9D,iBAAiB,EAAE;MAC5BlC,IAAI,CAACqD,IAAI,CAAC,gBAAgB,GACtB2C,MAAM,GACN,yKAAyK,CAAC;IAClL;IACAkC,KAAK,CAACU,OAAO,CAAC;MAAElB,KAAK,EAAE,IAAI,CAACA,KAAK,CAAC,CAAC;MAAEC,MAAM,EAAE,IAAI,CAACA,MAAM,CAAC;IAAE,CAAC,CAAC;IAC7DO,KAAK,CAACW,IAAI,CAAC,CAAC;IACZ,IAAI1I,KAAK,CAAC+I,SAAS,EAAE;MACjB,IAAI,CAACxE,OAAO,CAACgB,WAAW,CAACwC,KAAK,CAACN,MAAM,CAACf,OAAO,CAAC;IAClD;IACA,OAAO,IAAI;EACf;EACAsC,SAASA,CAAA,EAAG;IACR,OAAO,IAAI;EACf;EACAC,QAAQA,CAAA,EAAG;IACP,OAAO,IAAI;EACf;EACAC,iBAAiBA,CAACC,SAAS,EAAE;IACzB,OAAO9I,aAAa,CAAC6I,iBAAiB,CAACC,SAAS,EAAE,IAAI,CAAC;EAC3D;EACAC,iBAAiBA,CAACD,SAAS,EAAE;IACzB9I,aAAa,CAAC+I,iBAAiB,CAACD,SAAS,EAAE,IAAI,CAAC;EACpD;EACAE,cAAcA,CAACF,SAAS,EAAE;IACtB9I,aAAa,CAACgJ,cAAc,CAACF,SAAS,EAAE,IAAI,CAAC;EACjD;EACAG,SAASA,CAAA,EAAG;IACR,OAAO,IAAI,CAAC3D,QAAQ;EACxB;EACAhC,kBAAkBA,CAAA,EAAG;IACjB,IAAI,CAAC3D,KAAK,CAAC+I,SAAS,EAAE;MAClB;IACJ;IACA/G,MAAM,CAAC8F,OAAO,CAAC,CAAC,CAACyB,KAAK,EAAEC,UAAU,CAAC,KAAK;MACpC,IAAI,CAACjF,OAAO,CAACkF,gBAAgB,CAACF,KAAK,EAAGG,GAAG,IAAK;QAC1C,IAAI,CAACF,UAAU,CAAC,CAACE,GAAG,CAAC;MACzB,CAAC,EAAE;QAAEC,OAAO,EAAE;MAAM,CAAC,CAAC;IAC1B,CAAC,CAAC;EACN;EACAC,aAAaA,CAACF,GAAG,EAAE;IACf,IAAI,CAACG,oBAAoB,CAACH,GAAG,CAAC;IAC9B,MAAMI,MAAM,GAAGpH,YAAY,CAACgH,GAAG,CAAClH,IAAI,CAAC;IACrC,IAAIsH,MAAM,EAAE;MACR,IAAI,CAACC,KAAK,CAACD,MAAM,CAACE,YAAY,EAAE;QAC5BN,GAAG,EAAEA,GAAG;QACRO,MAAM,EAAE,IAAI;QACZC,aAAa,EAAE;MACnB,CAAC,CAAC;IACN;EACJ;EACAC,YAAYA,CAACT,GAAG,EAAE;IACd,IAAI,CAACG,oBAAoB,CAACH,GAAG,CAAC;IAC9B,MAAMI,MAAM,GAAGpH,YAAY,CAACgH,GAAG,CAAClH,IAAI,CAAC;IACrC,IAAIsH,MAAM,EAAE;MACR,IAAI,CAACC,KAAK,CAACD,MAAM,CAACM,WAAW,EAAE;QAC3BV,GAAG,EAAEA,GAAG;QACRO,MAAM,EAAE,IAAI;QACZC,aAAa,EAAE;MACnB,CAAC,CAAC;IACN;EACJ;EACAG,eAAeA,CAACC,QAAQ,EAAE;IACtB,IAAI9B,KAAK,GAAG,IAAI,CAAC8B,QAAQ,GAAG,aAAa,CAAC;IAC1C,IAAI9B,KAAK,IAAI,CAACA,KAAK,CAACpB,QAAQ,CAAC,CAAC,EAAE;MAC5BoB,KAAK,GAAG,IAAI;IAChB;IACA,OAAOA,KAAK;EAChB;EACA+B,aAAaA,CAACb,GAAG,EAAE;IACf,MAAMI,MAAM,GAAGpH,YAAY,CAACgH,GAAG,CAAClH,IAAI,CAAC;IACrC,MAAMG,SAAS,GAAGJ,YAAY,CAACmH,GAAG,CAAClH,IAAI,CAAC;IACxC,IAAI,CAACsH,MAAM,EAAE;MACT;IACJ;IACA,IAAI,CAACD,oBAAoB,CAACH,GAAG,CAAC;IAC9B,MAAMc,WAAW,GAAG,IAAI,CAACH,eAAe,CAAC1H,SAAS,CAAC;IACnD,MAAM8H,aAAa,GAAG,EAAEzK,KAAK,CAAC0K,UAAU,CAAC,CAAC,IAAI1K,KAAK,CAAC2K,cAAc,CAAC,CAAC,CAAC,IAAI3K,KAAK,CAAC4K,gBAAgB;IAC/F,IAAIJ,WAAW,IAAIC,aAAa,EAAE;MAC9BD,WAAW,CAACK,cAAc,CAACf,MAAM,CAACgB,UAAU,EAAE;QAAEpB,GAAG,EAAEA;MAAI,CAAC,CAAC;MAC3Dc,WAAW,CAACK,cAAc,CAACf,MAAM,CAACiB,YAAY,EAAE;QAAErB,GAAG,EAAEA;MAAI,CAAC,CAAC;MAC7D,IAAI,CAACK,KAAK,CAACD,MAAM,CAACiB,YAAY,EAAE;QAC5BrB,GAAG,EAAEA,GAAG;QACRO,MAAM,EAAE,IAAI;QACZC,aAAa,EAAE;MACnB,CAAC,CAAC;MACF,IAAI,CAACvH,SAAS,GAAG,aAAa,CAAC,GAAG,IAAI;IAC1C,CAAC,MACI,IAAI8H,aAAa,EAAE;MACpB,IAAI,CAACV,KAAK,CAACD,MAAM,CAACiB,YAAY,EAAE;QAC5BrB,GAAG,EAAEA,GAAG;QACRO,MAAM,EAAE,IAAI;QACZC,aAAa,EAAE;MACnB,CAAC,CAAC;MACF,IAAI,CAACH,KAAK,CAACD,MAAM,CAACgB,UAAU,EAAE;QAC1BpB,GAAG,EAAEA,GAAG;QACRO,MAAM,EAAE,IAAI;QACZC,aAAa,EAAE;MACnB,CAAC,CAAC;IACN;IACA,IAAI,CAACc,UAAU,GAAG,IAAI;IACtB,IAAI,CAACxH,iBAAiB,GAAG,EAAE;EAC/B;EACAyH,YAAYA,CAACvB,GAAG,EAAE;IACd,MAAMI,MAAM,GAAGpH,YAAY,CAACgH,GAAG,CAAClH,IAAI,CAAC;IACrC,MAAMG,SAAS,GAAGJ,YAAY,CAACmH,GAAG,CAAClH,IAAI,CAAC;IACxC,IAAI,CAACsH,MAAM,EAAE;MACT;IACJ;IACA,IAAI,CAACD,oBAAoB,CAACH,GAAG,CAAC;IAC9B,IAAIwB,gBAAgB,GAAG,KAAK;IAC5B,IAAI,CAACzH,wBAAwB,CAACqE,OAAO,CAAEjB,GAAG,IAAK;MAC3C,MAAM2B,KAAK,GAAG,IAAI,CAACF,eAAe,CAACzB,GAAG,CAAC;MACvC1G,EAAE,CAACgL,WAAW,GAAG,KAAK;MACtBnL,KAAK,CAAC,GAAG,GAAG2C,SAAS,GAAG,aAAa,CAAC,GAAG,IAAI;MAC7C,IAAI,CAAC6F,KAAK,IAAI,CAACA,KAAK,CAAC4C,WAAW,CAAC,CAAC,EAAE;QAChC,IAAI,CAACzI,SAAS,GAAG,iBAAiB,CAAC,GAAG0I,SAAS;QAC/C;MACJ;MACA,IAAIrL,KAAK,CAACsL,2BAA2B,EAAE;QACnC9C,KAAK,CAACY,iBAAiB,CAACvC,GAAG,CAAChC,EAAE,CAAC;MACnC;MACA,IAAI,CAAClC,SAAS,GAAG,iBAAiB,CAAC,GAAG6F,KAAK;MAC3CA,KAAK,CAACqC,cAAc,CAACf,MAAM,CAACyB,WAAW,EAAE;QACrC7B,GAAG,EAAEA,GAAG;QACRP,SAAS,EAAEtC,GAAG,CAAChC;MACnB,CAAC,CAAC;MACFqG,gBAAgB,GAAG,IAAI;MACvB,MAAMM,OAAO,GAAG9B,GAAG,CAAClH,IAAI,CAACC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC;MAC9C,IAAI+F,KAAK,CAACiD,cAAc,CAAC,CAAC,IAAI/B,GAAG,CAACgC,UAAU,IAAIF,OAAO,EAAE;QACrD9B,GAAG,CAAC+B,cAAc,CAAC,CAAC;MACxB;IACJ,CAAC,CAAC;IACF,IAAI,CAACP,gBAAgB,EAAE;MACnB,IAAI,CAACnB,KAAK,CAACD,MAAM,CAACyB,WAAW,EAAE;QAC3B7B,GAAG,EAAEA,GAAG;QACRO,MAAM,EAAE,IAAI;QACZC,aAAa,EAAE,IAAI;QACnBf,SAAS,EAAE,IAAI,CAAC3F,iBAAiB,CAAC,CAAC,CAAC,CAACqB;MACzC,CAAC,CAAC;IACN;EACJ;EACA8G,YAAYA,CAACjC,GAAG,EAAE;IACd,MAAMI,MAAM,GAAGpH,YAAY,CAACgH,GAAG,CAAClH,IAAI,CAAC;IACrC,MAAMG,SAAS,GAAGJ,YAAY,CAACmH,GAAG,CAAClH,IAAI,CAAC;IACxC,IAAI,CAACsH,MAAM,EAAE;MACT;IACJ;IACA,MAAM8B,cAAc,GAAGlC,GAAG,CAAClH,IAAI,CAACC,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,IACjDiH,GAAG,CAACmC,WAAW,KAAK,OAAO;IAC/B,IAAI7L,KAAK,CAAC0K,UAAU,CAAC,CAAC,IAClBvK,EAAE,CAAC2L,IAAI,CAACL,cAAc,CAAC,CAAC,IACxB/B,GAAG,CAACgC,UAAU,IACdE,cAAc,EAAE;MAChBlC,GAAG,CAAC+B,cAAc,CAAC,CAAC;IACxB;IACA,IAAI,CAAC5B,oBAAoB,CAACH,GAAG,CAAC;IAC9B,MAAMe,aAAa,GAAG,EAAEzK,KAAK,CAAC0K,UAAU,CAAC,CAAC,IAAI1K,KAAK,CAAC2K,cAAc,CAAC,CAAC,CAAC,IAAI3K,KAAK,CAAC4K,gBAAgB;IAC/F,IAAI,CAACH,aAAa,EAAE;MAChB;IACJ;IACA,MAAMsB,kBAAkB,GAAG,CAAC,CAAC;IAC7B,IAAIb,gBAAgB,GAAG,KAAK;IAC5B,MAAMV,WAAW,GAAG,IAAI,CAACH,eAAe,CAAC1H,SAAS,CAAC;IACnD,IAAI,CAACc,wBAAwB,CAACqE,OAAO,CAAEjB,GAAG,IAAK;MAC3C,MAAM2B,KAAK,GAAInI,aAAa,CAAC2L,gBAAgB,CAACnF,GAAG,CAAChC,EAAE,CAAC,IACjD,IAAI,CAACyD,eAAe,CAACzB,GAAG,CAAE;MAC9B,MAAMsC,SAAS,GAAGtC,GAAG,CAAChC,EAAE;MACxB,MAAM0E,KAAK,GAAG;QAAEG,GAAG,EAAEA,GAAG;QAAEP;MAAU,CAAC;MACrC,MAAM8C,eAAe,GAAGzB,WAAW,KAAKhC,KAAK;MAC7C,IAAIyD,eAAe,IAAIzB,WAAW,EAAE;QAChCA,WAAW,CAACK,cAAc,CAACf,MAAM,CAACgB,UAAU,EAAE;UAAE,GAAGvB;QAAM,CAAC,EAAEf,KAAK,CAAC;QAClEgC,WAAW,CAACK,cAAc,CAACf,MAAM,CAACiB,YAAY,EAAE;UAAE,GAAGxB;QAAM,CAAC,EAAEf,KAAK,CAAC;MACxE;MACA,IAAIA,KAAK,EAAE;QACP,IAAIuD,kBAAkB,CAACvD,KAAK,CAAC0D,GAAG,CAAC,EAAE;UAC/B;QACJ;QACAH,kBAAkB,CAACvD,KAAK,CAAC0D,GAAG,CAAC,GAAG,IAAI;MACxC;MACA,IAAI1D,KAAK,IAAIA,KAAK,CAAC4C,WAAW,CAAC,CAAC,EAAE;QAC9BF,gBAAgB,GAAG,IAAI;QACvB,IAAIe,eAAe,EAAE;UACjBzD,KAAK,CAACqC,cAAc,CAACf,MAAM,CAACM,WAAW,EAAE;YAAE,GAAGb;UAAM,CAAC,EAAEiB,WAAW,CAAC;UACnEhC,KAAK,CAACqC,cAAc,CAACf,MAAM,CAACE,YAAY,EAAE;YAAE,GAAGT;UAAM,CAAC,EAAEiB,WAAW,CAAC;UACpE,IAAI,CAAC7H,SAAS,GAAG,aAAa,CAAC,GAAG6F,KAAK;QAC3C;QACAA,KAAK,CAACqC,cAAc,CAACf,MAAM,CAACqC,WAAW,EAAE;UAAE,GAAG5C;QAAM,CAAC,CAAC;MAC1D,CAAC,MACI;QACD,IAAIiB,WAAW,EAAE;UACb,IAAI,CAACT,KAAK,CAACD,MAAM,CAACM,WAAW,EAAE;YAC3BV,GAAG,EAAEA,GAAG;YACRO,MAAM,EAAE,IAAI;YACZC,aAAa,EAAE,IAAI;YACnBf;UACJ,CAAC,CAAC;UACF,IAAI,CAACxG,SAAS,GAAG,aAAa,CAAC,GAAG,IAAI;QAC1C;MACJ;IACJ,CAAC,CAAC;IACF,IAAI,CAACuI,gBAAgB,EAAE;MACnB,IAAI,CAACnB,KAAK,CAACD,MAAM,CAACqC,WAAW,EAAE;QAC3BzC,GAAG,EAAEA,GAAG;QACRO,MAAM,EAAE,IAAI;QACZC,aAAa,EAAE,IAAI;QACnBf,SAAS,EAAE,IAAI,CAAC1F,wBAAwB,CAAC,CAAC,CAAC,CAACoB;MAChD,CAAC,CAAC;IACN;EACJ;EACAuH,UAAUA,CAAC1C,GAAG,EAAE;IACZ,MAAMI,MAAM,GAAGpH,YAAY,CAACgH,GAAG,CAAClH,IAAI,CAAC;IACrC,MAAMG,SAAS,GAAGJ,YAAY,CAACmH,GAAG,CAAClH,IAAI,CAAC;IACxC,IAAI,CAACsH,MAAM,EAAE;MACT;IACJ;IACA,IAAI,CAACD,oBAAoB,CAACH,GAAG,CAAC;IAC9B,MAAM2C,eAAe,GAAG,IAAI,CAAC1J,SAAS,GAAG,iBAAiB,CAAC;IAC3D,MAAM2J,aAAa,GAAG,IAAI,CAAC3J,SAAS,GAAG,eAAe,CAAC;IACvD,MAAMoJ,kBAAkB,GAAG,CAAC,CAAC;IAC7B,IAAIQ,oBAAoB,GAAG,KAAK;IAChC,IAAI,CAAC9I,wBAAwB,CAACqE,OAAO,CAAEjB,GAAG,IAAK;MAC3C,MAAM2B,KAAK,GAAInI,aAAa,CAAC2L,gBAAgB,CAACnF,GAAG,CAAChC,EAAE,CAAC,IACjD,IAAI,CAACyD,eAAe,CAACzB,GAAG,CAAE;MAC9B,IAAI2B,KAAK,EAAE;QACPA,KAAK,CAACa,cAAc,CAACxC,GAAG,CAAChC,EAAE,CAAC;QAC5B,IAAIkH,kBAAkB,CAACvD,KAAK,CAAC0D,GAAG,CAAC,EAAE;UAC/B;QACJ;QACAH,kBAAkB,CAACvD,KAAK,CAAC0D,GAAG,CAAC,GAAG,IAAI;MACxC;MACA,MAAM/C,SAAS,GAAGtC,GAAG,CAAChC,EAAE;MACxB,MAAM0E,KAAK,GAAG;QAAEG,GAAG,EAAEA,GAAG;QAAEP;MAAU,CAAC;MACrC,IAAIqD,YAAY,GAAG,KAAK;MACxB,IAAIxM,KAAK,CAAC,GAAG,GAAG2C,SAAS,GAAG,kBAAkB,CAAC,EAAE;QAC7C6J,YAAY,GAAG,IAAI;QACnBC,YAAY,CAAC,IAAI,CAAC9J,SAAS,GAAG,YAAY,CAAC,CAAC;MAChD,CAAC,MACI,IAAI,CAACxC,EAAE,CAACgL,WAAW,EAAE;QACtBnL,KAAK,CAAC,GAAG,GAAG2C,SAAS,GAAG,kBAAkB,CAAC,GAAG,IAAI;QAClD8J,YAAY,CAAC,IAAI,CAAC9J,SAAS,GAAG,YAAY,CAAC,CAAC;MAChD;MACA,IAAI,CAACA,SAAS,GAAG,YAAY,CAAC,GAAG+J,UAAU,CAAC,YAAY;QACpD1M,KAAK,CAAC,GAAG,GAAG2C,SAAS,GAAG,kBAAkB,CAAC,GAAG,KAAK;MACvD,CAAC,EAAE3C,KAAK,CAAC2M,cAAc,CAAC;MACxB,IAAInE,KAAK,IAAIA,KAAK,CAAC4C,WAAW,CAAC,CAAC,EAAE;QAC9BmB,oBAAoB,GAAG,IAAI;QAC3B,IAAI,CAAC5J,SAAS,GAAG,eAAe,CAAC,GAAG6F,KAAK;QACzCA,KAAK,CAACqC,cAAc,CAACf,MAAM,CAAC8C,SAAS,EAAE;UAAE,GAAGrD;QAAM,CAAC,CAAC;QACpD,IAAIvJ,KAAK,CAAC,GAAG,GAAG2C,SAAS,GAAG,aAAa,CAAC,IACtC0J,eAAe,IACfA,eAAe,KAAK7D,KAAK,EAAE;UAC3BA,KAAK,CAACqC,cAAc,CAACf,MAAM,CAAC3H,YAAY,EAAE;YAAE,GAAGoH;UAAM,CAAC,CAAC;UACvD,IAAIiD,YAAY,IAAIF,aAAa,IAAIA,aAAa,KAAK9D,KAAK,EAAE;YAC1DA,KAAK,CAACqC,cAAc,CAACf,MAAM,CAAC1H,eAAe,EAAE;cAAE,GAAGmH;YAAM,CAAC,CAAC;UAC9D;QACJ;MACJ,CAAC,MACI;QACD,IAAI,CAAC5G,SAAS,GAAG,eAAe,CAAC,GAAG,IAAI;QACxC,IAAI,CAAC4J,oBAAoB,EAAE;UACvB,IAAI,CAACxC,KAAK,CAACD,MAAM,CAAC8C,SAAS,EAAE;YACzBlD,GAAG,EAAEA,GAAG;YACRO,MAAM,EAAE,IAAI;YACZC,aAAa,EAAE,IAAI;YACnBf,SAAS,EAAE,IAAI,CAAC1F,wBAAwB,CAAC,CAAC,CAAC,CAACoB;UAChD,CAAC,CAAC;UACF0H,oBAAoB,GAAG,IAAI;QAC/B;QACA,IAAIvM,KAAK,CAAC,GAAG,GAAG2C,SAAS,GAAG,aAAa,CAAC,EAAE;UACxC,IAAI,CAACoH,KAAK,CAACD,MAAM,CAAC3H,YAAY,EAAE;YAC5BuH,GAAG,EAAEA,GAAG;YACRO,MAAM,EAAE,IAAI;YACZC,aAAa,EAAE,IAAI;YACnBf;UACJ,CAAC,CAAC;QACN;QACA,IAAIqD,YAAY,EAAE;UACd,IAAI,CAACzC,KAAK,CAACD,MAAM,CAAC1H,eAAe,EAAE;YAC/BsH,GAAG,EAAEA,GAAG;YACRO,MAAM,EAAE,IAAI;YACZC,aAAa,EAAE,IAAI;YACnBf;UACJ,CAAC,CAAC;QACN;MACJ;IACJ,CAAC,CAAC;IACF,IAAI,CAACoD,oBAAoB,EAAE;MACvB,IAAI,CAACxC,KAAK,CAACD,MAAM,CAAC8C,SAAS,EAAE;QACzBlD,GAAG,EAAEA,GAAG;QACRO,MAAM,EAAE,IAAI;QACZC,aAAa,EAAE,IAAI;QACnBf,SAAS,EAAE,IAAI,CAAC1F,wBAAwB,CAAC,CAAC,CAAC,CAACoB;MAChD,CAAC,CAAC;IACN;IACA7E,KAAK,CAAC,GAAG,GAAG2C,SAAS,GAAG,aAAa,CAAC,GAAG,KAAK;IAC9C,IAAI+G,GAAG,CAACgC,UAAU,IAAI/I,SAAS,KAAK,OAAO,IAAIA,SAAS,KAAK,SAAS,EAAE;MACpE+G,GAAG,CAAC+B,cAAc,CAAC,CAAC;IACxB;EACJ;EACAoB,YAAYA,CAACnD,GAAG,EAAE;IACd,IAAI,CAACG,oBAAoB,CAACH,GAAG,CAAC;IAC9B,MAAMlB,KAAK,GAAG,IAAI,CAACF,eAAe,CAAC,IAAI,CAAC1B,kBAAkB,CAAC,CAAC,CAAC;IAC7D,IAAI4B,KAAK,IAAIA,KAAK,CAAC4C,WAAW,CAAC,CAAC,EAAE;MAC9B5C,KAAK,CAACqC,cAAc,CAACpJ,WAAW,EAAE;QAAEiI,GAAG,EAAEA;MAAI,CAAC,CAAC;IACnD,CAAC,MACI;MACD,IAAI,CAACK,KAAK,CAACtI,WAAW,EAAE;QACpBiI,GAAG,EAAEA,GAAG;QACRO,MAAM,EAAE,IAAI;QACZC,aAAa,EAAE;MACnB,CAAC,CAAC;IACN;EACJ;EACA4C,MAAMA,CAACpD,GAAG,EAAE;IACR,IAAI,CAACG,oBAAoB,CAACH,GAAG,CAAC;IAC9B,MAAMlB,KAAK,GAAG,IAAI,CAACF,eAAe,CAAC,IAAI,CAAC1B,kBAAkB,CAAC,CAAC,CAAC;IAC7D,IAAI4B,KAAK,IAAIA,KAAK,CAAC4C,WAAW,CAAC,CAAC,EAAE;MAC9B5C,KAAK,CAACqC,cAAc,CAAC/I,KAAK,EAAE;QAAE4H,GAAG,EAAEA;MAAI,CAAC,CAAC;IAC7C,CAAC,MACI;MACD,IAAI,CAACK,KAAK,CAACjI,KAAK,EAAE;QACd4H,GAAG,EAAEA,GAAG;QACRO,MAAM,EAAE,IAAI;QACZC,aAAa,EAAE;MACnB,CAAC,CAAC;IACN;EACJ;EACA6C,cAAcA,CAACrD,GAAG,EAAE;IAChB,IAAI,CAACG,oBAAoB,CAACH,GAAG,CAAC;IAC9B,MAAMlB,KAAK,GAAGnI,aAAa,CAAC2L,gBAAgB,CAACtC,GAAG,CAACP,SAAS,CAAC,IACvD,IAAI,CAACb,eAAe,CAAC,IAAI,CAAC1B,kBAAkB,CAAC,CAAC,CAAC;IACnD,IAAI4B,KAAK,EAAE;MACPA,KAAK,CAACqC,cAAc,CAAC3J,SAAS,EAAEb,aAAa,CAAC2M,WAAW,CAACtD,GAAG,CAAC,CAAC;IACnE;IACArJ,aAAa,CAACgJ,cAAc,CAACK,GAAG,CAACP,SAAS,CAAC;EAC/C;EACA8D,mBAAmBA,CAACvD,GAAG,EAAE;IACrBrJ,aAAa,CAACgJ,cAAc,CAACK,GAAG,CAACP,SAAS,CAAC;EAC/C;EACAU,oBAAoBA,CAACH,GAAG,EAAE;IACtB,MAAMwD,eAAe,GAAG,IAAI,CAACC,mBAAmB,CAAC,CAAC;IAClD,IAAIrG,CAAC,GAAG,IAAI;MAAEC,CAAC,GAAG,IAAI;IACtB2C,GAAG,GAAGA,GAAG,GAAGA,GAAG,GAAG0D,MAAM,CAAC7D,KAAK;IAC9B,IAAIG,GAAG,CAAC2D,OAAO,KAAKhC,SAAS,EAAE;MAC3B,IAAI,CAAC7H,iBAAiB,GAAG,EAAE;MAC3B,IAAI,CAACC,wBAAwB,GAAG,EAAE;MAClC6J,KAAK,CAACpH,SAAS,CAAC4B,OAAO,CAAC3B,IAAI,CAACuD,GAAG,CAAC2D,OAAO,EAAGhL,KAAK,IAAK;QACjD,IAAI,CAACmB,iBAAiB,CAACI,IAAI,CAAC;UACxBiB,EAAE,EAAExC,KAAK,CAACkL,UAAU;UACpBzG,CAAC,EAAE,CAACzE,KAAK,CAACmL,OAAO,GAAGN,eAAe,CAACO,IAAI,IAAIP,eAAe,CAACQ,MAAM;UAClE3G,CAAC,EAAE,CAAC1E,KAAK,CAACsL,OAAO,GAAGT,eAAe,CAACU,GAAG,IAAIV,eAAe,CAACW;QAC/D,CAAC,CAAC;MACN,CAAC,CAAC;MACFP,KAAK,CAACpH,SAAS,CAAC4B,OAAO,CAAC3B,IAAI,CAACuD,GAAG,CAACoE,cAAc,IAAIpE,GAAG,CAAC2D,OAAO,EAAGhL,KAAK,IAAK;QACvE,IAAI,CAACoB,wBAAwB,CAACG,IAAI,CAAC;UAC/BiB,EAAE,EAAExC,KAAK,CAACkL,UAAU;UACpBzG,CAAC,EAAE,CAACzE,KAAK,CAACmL,OAAO,GAAGN,eAAe,CAACO,IAAI,IAAIP,eAAe,CAACQ,MAAM;UAClE3G,CAAC,EAAE,CAAC1E,KAAK,CAACsL,OAAO,GAAGT,eAAe,CAACU,GAAG,IAAIV,eAAe,CAACW;QAC/D,CAAC,CAAC;MACN,CAAC,CAAC;IACN,CAAC,MACI;MACD/G,CAAC,GAAG,CAAC4C,GAAG,CAAC8D,OAAO,GAAGN,eAAe,CAACO,IAAI,IAAIP,eAAe,CAACQ,MAAM;MACjE3G,CAAC,GAAG,CAAC2C,GAAG,CAACiE,OAAO,GAAGT,eAAe,CAACU,GAAG,IAAIV,eAAe,CAACW,MAAM;MAChE,IAAI,CAAC7C,UAAU,GAAG;QACdlE,CAAC,EAAEA,CAAC;QACJC,CAAC,EAAEA;MACP,CAAC;MACD,IAAI,CAACvD,iBAAiB,GAAG,CAAC;QAAEsD,CAAC;QAAEC,CAAC;QAAElC,EAAE,EAAEhF,IAAI,CAACkO,kBAAkB,CAACrE,GAAG;MAAE,CAAC,CAAC;MACrE,IAAI,CAACjG,wBAAwB,GAAG,CAC5B;QAAEqD,CAAC;QAAEC,CAAC;QAAElC,EAAE,EAAEhF,IAAI,CAACkO,kBAAkB,CAACrE,GAAG;MAAE,CAAC,CAC7C;IACL;EACJ;EACAsE,mBAAmBA,CAACtE,GAAG,EAAE;IACrB7J,IAAI,CAACqD,IAAI,CAAC,4FAA4F,CAAC;IACvG,IAAI,CAAC2G,oBAAoB,CAACH,GAAG,CAAC;EAClC;EACAyD,mBAAmBA,CAAA,EAAG;IAClB,IAAI,CAAC,IAAI,CAAC5I,OAAO,IAAI,CAAC,IAAI,CAACA,OAAO,CAAC0J,qBAAqB,EAAE;MACtD,OAAO;QACHL,GAAG,EAAE,CAAC;QACNH,IAAI,EAAE,CAAC;QACPC,MAAM,EAAE,CAAC;QACTG,MAAM,EAAE;MACZ,CAAC;IACL;IACA,MAAMK,IAAI,GAAG,IAAI,CAAC3J,OAAO,CAAC0J,qBAAqB,CAAC,CAAC;IACjD,OAAO;MACHL,GAAG,EAAEM,IAAI,CAACN,GAAG;MACbH,IAAI,EAAES,IAAI,CAACT,IAAI;MACfC,MAAM,EAAEQ,IAAI,CAAC3G,KAAK,GAAG,IAAI,CAAChD,OAAO,CAAC4J,WAAW,IAAI,CAAC;MAClDN,MAAM,EAAEK,IAAI,CAAC1G,MAAM,GAAG,IAAI,CAACjD,OAAO,CAAC6J,YAAY,IAAI;IACvD,CAAC;EACL;EACA1K,SAASA,CAAA,EAAG;IACR,IAAI,CAAC+C,YAAY,GAAG,IAAIxG,WAAW,CAAC;MAChCsH,KAAK,EAAE,IAAI,CAACA,KAAK,CAAC,CAAC;MACnBC,MAAM,EAAE,IAAI,CAACA,MAAM,CAAC;IACxB,CAAC,CAAC;IACF,IAAI,CAACb,eAAe,GAAG,IAAIzG,SAAS,CAAC;MACjCwH,UAAU,EAAE,CAAC;MACbH,KAAK,EAAE,IAAI,CAACA,KAAK,CAAC,CAAC;MACnBC,MAAM,EAAE,IAAI,CAACA,MAAM,CAAC;IACxB,CAAC,CAAC;IACF,IAAI,CAACxH,KAAK,CAAC+I,SAAS,EAAE;MAClB;IACJ;IACA,MAAMnE,SAAS,GAAG,IAAI,CAACA,SAAS,CAAC,CAAC;IAClC,IAAI,CAACA,SAAS,EAAE;MACZ,MAAM,kDAAkD;IAC5D;IACAA,SAAS,CAACyJ,SAAS,GAAG,EAAE;IACxB,IAAI,CAAC9J,OAAO,GAAGU,QAAQ,CAACgB,aAAa,CAAC,KAAK,CAAC;IAC5C,IAAI,CAAC1B,OAAO,CAACC,KAAK,CAAC8J,QAAQ,GAAG,UAAU;IACxC,IAAI,CAAC/J,OAAO,CAACC,KAAK,CAAC+J,UAAU,GAAG,MAAM;IACtC,IAAI,CAAChK,OAAO,CAACQ,SAAS,GAAG,iBAAiB;IAC1C,IAAI,CAACR,OAAO,CAACiK,YAAY,CAAC,MAAM,EAAE,cAAc,CAAC;IACjD5J,SAAS,CAACW,WAAW,CAAC,IAAI,CAAChB,OAAO,CAAC;IACnC,IAAI,CAACT,UAAU,CAAC,CAAC;EACrB;EACA2K,KAAKA,CAAA,EAAG;IACJ5O,IAAI,CAACqD,IAAI,CAAC,gGAAgG,CAAC;IAC3G,OAAO,IAAI;EACf;EACAwL,UAAUA,CAAA,EAAG;IACT,OAAO,IAAI;EACf;EACAC,SAASA,CAAA,EAAG;IACR,IAAI,CAACC,WAAW,CAAC,CAAC,CAAC9G,OAAO,CAAC,UAAUC,KAAK,EAAE;MACxCA,KAAK,CAAC4G,SAAS,CAAC,CAAC;IACrB,CAAC,CAAC;IACF,OAAO,IAAI;EACf;AACJ;AACAtL,KAAK,CAAC6C,SAAS,CAAC2I,QAAQ,GAAGvO,KAAK;AAChCF,aAAa,CAACiD,KAAK,CAAC;AACpBvD,OAAO,CAACgP,eAAe,CAACzL,KAAK,EAAE,WAAW,CAAC;AAC3C,IAAIrD,KAAK,CAAC+I,SAAS,EAAE;EACjB9D,QAAQ,CAACwE,gBAAgB,CAAC,kBAAkB,EAAE,MAAM;IAChDrG,MAAM,CAAC0E,OAAO,CAAEiH,KAAK,IAAK;MACtBA,KAAK,CAACJ,SAAS,CAAC,CAAC;IACrB,CAAC,CAAC;EACN,CAAC,CAAC;AACN","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}