{"ast":null,"code":"import { Konva } from \"./Global.js\";\nimport { Transform, Util } from \"./Util.js\";\nimport { Factory } from \"./Factory.js\";\nimport { Node } from \"./Node.js\";\nimport { getNumberValidator, getNumberOrAutoValidator, getStringValidator, getBooleanValidator, getStringOrGradientValidator } from \"./Validators.js\";\nimport { _registerNode } from \"./Global.js\";\nimport * as PointerEvents from \"./PointerEvents.js\";\nconst HAS_SHADOW = 'hasShadow';\nconst SHADOW_RGBA = 'shadowRGBA';\nconst patternImage = 'patternImage';\nconst linearGradient = 'linearGradient';\nconst radialGradient = 'radialGradient';\nlet dummyContext;\nfunction getDummyContext() {\n  if (dummyContext) {\n    return dummyContext;\n  }\n  dummyContext = Util.createCanvasElement().getContext('2d');\n  return dummyContext;\n}\nexport const shapes = {};\nfunction _fillFunc(context) {\n  const fillRule = this.attrs.fillRule;\n  if (fillRule) {\n    context.fill(fillRule);\n  } else {\n    context.fill();\n  }\n}\nfunction _strokeFunc(context) {\n  context.stroke();\n}\nfunction _fillFuncHit(context) {\n  const fillRule = this.attrs.fillRule;\n  if (fillRule) {\n    context.fill(fillRule);\n  } else {\n    context.fill();\n  }\n}\nfunction _strokeFuncHit(context) {\n  context.stroke();\n}\nfunction _clearHasShadowCache() {\n  this._clearCache(HAS_SHADOW);\n}\nfunction _clearGetShadowRGBACache() {\n  this._clearCache(SHADOW_RGBA);\n}\nfunction _clearFillPatternCache() {\n  this._clearCache(patternImage);\n}\nfunction _clearLinearGradientCache() {\n  this._clearCache(linearGradient);\n}\nfunction _clearRadialGradientCache() {\n  this._clearCache(radialGradient);\n}\nexport class Shape extends Node {\n  constructor(config) {\n    super(config);\n    let key;\n    while (true) {\n      key = Util.getRandomColor();\n      if (key && !(key in shapes)) {\n        break;\n      }\n    }\n    this.colorKey = key;\n    shapes[key] = this;\n  }\n  getContext() {\n    Util.warn('shape.getContext() method is deprecated. Please do not use it.');\n    return this.getLayer().getContext();\n  }\n  getCanvas() {\n    Util.warn('shape.getCanvas() method is deprecated. Please do not use it.');\n    return this.getLayer().getCanvas();\n  }\n  getSceneFunc() {\n    return this.attrs.sceneFunc || this['_sceneFunc'];\n  }\n  getHitFunc() {\n    return this.attrs.hitFunc || this['_hitFunc'];\n  }\n  hasShadow() {\n    return this._getCache(HAS_SHADOW, this._hasShadow);\n  }\n  _hasShadow() {\n    return this.shadowEnabled() && this.shadowOpacity() !== 0 && !!(this.shadowColor() || this.shadowBlur() || this.shadowOffsetX() || this.shadowOffsetY());\n  }\n  _getFillPattern() {\n    return this._getCache(patternImage, this.__getFillPattern);\n  }\n  __getFillPattern() {\n    if (this.fillPatternImage()) {\n      const ctx = getDummyContext();\n      const pattern = ctx.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || 'repeat');\n      if (pattern && pattern.setTransform) {\n        const tr = new Transform();\n        tr.translate(this.fillPatternX(), this.fillPatternY());\n        tr.rotate(Konva.getAngle(this.fillPatternRotation()));\n        tr.scale(this.fillPatternScaleX(), this.fillPatternScaleY());\n        tr.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());\n        const m = tr.getMatrix();\n        const matrix = typeof DOMMatrix === 'undefined' ? {\n          a: m[0],\n          b: m[1],\n          c: m[2],\n          d: m[3],\n          e: m[4],\n          f: m[5]\n        } : new DOMMatrix(m);\n        pattern.setTransform(matrix);\n      }\n      return pattern;\n    }\n  }\n  _getLinearGradient() {\n    return this._getCache(linearGradient, this.__getLinearGradient);\n  }\n  __getLinearGradient() {\n    const colorStops = this.fillLinearGradientColorStops();\n    if (colorStops) {\n      const ctx = getDummyContext();\n      const start = this.fillLinearGradientStartPoint();\n      const end = this.fillLinearGradientEndPoint();\n      const grd = ctx.createLinearGradient(start.x, start.y, end.x, end.y);\n      for (let n = 0; n < colorStops.length; n += 2) {\n        grd.addColorStop(colorStops[n], colorStops[n + 1]);\n      }\n      return grd;\n    }\n  }\n  _getRadialGradient() {\n    return this._getCache(radialGradient, this.__getRadialGradient);\n  }\n  __getRadialGradient() {\n    const colorStops = this.fillRadialGradientColorStops();\n    if (colorStops) {\n      const ctx = getDummyContext();\n      const start = this.fillRadialGradientStartPoint();\n      const end = this.fillRadialGradientEndPoint();\n      const grd = ctx.createRadialGradient(start.x, start.y, this.fillRadialGradientStartRadius(), end.x, end.y, this.fillRadialGradientEndRadius());\n      for (let n = 0; n < colorStops.length; n += 2) {\n        grd.addColorStop(colorStops[n], colorStops[n + 1]);\n      }\n      return grd;\n    }\n  }\n  getShadowRGBA() {\n    return this._getCache(SHADOW_RGBA, this._getShadowRGBA);\n  }\n  _getShadowRGBA() {\n    if (!this.hasShadow()) {\n      return;\n    }\n    const rgba = Util.colorToRGBA(this.shadowColor());\n    if (rgba) {\n      return 'rgba(' + rgba.r + ',' + rgba.g + ',' + rgba.b + ',' + rgba.a * (this.shadowOpacity() || 1) + ')';\n    }\n  }\n  hasFill() {\n    return this._calculate('hasFill', ['fillEnabled', 'fill', 'fillPatternImage', 'fillLinearGradientColorStops', 'fillRadialGradientColorStops'], () => {\n      return this.fillEnabled() && !!(this.fill() || this.fillPatternImage() || this.fillLinearGradientColorStops() || this.fillRadialGradientColorStops());\n    });\n  }\n  hasStroke() {\n    return this._calculate('hasStroke', ['strokeEnabled', 'strokeWidth', 'stroke', 'strokeLinearGradientColorStops'], () => {\n      return this.strokeEnabled() && this.strokeWidth() && !!(this.stroke() || this.strokeLinearGradientColorStops());\n    });\n  }\n  hasHitStroke() {\n    const width = this.hitStrokeWidth();\n    if (width === 'auto') {\n      return this.hasStroke();\n    }\n    return this.strokeEnabled() && !!width;\n  }\n  intersects(point) {\n    const stage = this.getStage();\n    if (!stage) {\n      return false;\n    }\n    const bufferHitCanvas = stage.bufferHitCanvas;\n    bufferHitCanvas.getContext().clear();\n    this.drawHit(bufferHitCanvas, undefined, true);\n    const p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;\n    return p[3] > 0;\n  }\n  destroy() {\n    Node.prototype.destroy.call(this);\n    delete shapes[this.colorKey];\n    delete this.colorKey;\n    return this;\n  }\n  _useBufferCanvas(forceFill) {\n    var _a;\n    const perfectDrawEnabled = (_a = this.attrs.perfectDrawEnabled) !== null && _a !== void 0 ? _a : true;\n    if (!perfectDrawEnabled) {\n      return false;\n    }\n    const hasFill = forceFill || this.hasFill();\n    const hasStroke = this.hasStroke();\n    const isTransparent = this.getAbsoluteOpacity() !== 1;\n    if (hasFill && hasStroke && isTransparent) {\n      return true;\n    }\n    const hasShadow = this.hasShadow();\n    const strokeForShadow = this.shadowForStrokeEnabled();\n    if (hasFill && hasStroke && hasShadow && strokeForShadow) {\n      return true;\n    }\n    return false;\n  }\n  setStrokeHitEnabled(val) {\n    Util.warn('strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead.');\n    if (val) {\n      this.hitStrokeWidth('auto');\n    } else {\n      this.hitStrokeWidth(0);\n    }\n  }\n  getStrokeHitEnabled() {\n    if (this.hitStrokeWidth() === 0) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n  getSelfRect() {\n    const size = this.size();\n    return {\n      x: this._centroid ? -size.width / 2 : 0,\n      y: this._centroid ? -size.height / 2 : 0,\n      width: size.width,\n      height: size.height\n    };\n  }\n  getClientRect() {\n    let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let hasCachedParent = false;\n    let parent = this.getParent();\n    while (parent) {\n      if (parent.isCached()) {\n        hasCachedParent = true;\n        break;\n      }\n      parent = parent.getParent();\n    }\n    const skipTransform = config.skipTransform;\n    const relativeTo = config.relativeTo || hasCachedParent && this.getStage() || undefined;\n    const fillRect = this.getSelfRect();\n    const applyStroke = !config.skipStroke && this.hasStroke();\n    const strokeWidth = applyStroke && this.strokeWidth() || 0;\n    const fillAndStrokeWidth = fillRect.width + strokeWidth;\n    const fillAndStrokeHeight = fillRect.height + strokeWidth;\n    const applyShadow = !config.skipShadow && this.hasShadow();\n    const shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0;\n    const shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0;\n    const preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);\n    const preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);\n    const blurRadius = applyShadow && this.shadowBlur() || 0;\n    const width = preWidth + blurRadius * 2;\n    const height = preHeight + blurRadius * 2;\n    const rect = {\n      width: width,\n      height: height,\n      x: -(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetX, 0) + fillRect.x,\n      y: -(strokeWidth / 2 + blurRadius) + Math.min(shadowOffsetY, 0) + fillRect.y\n    };\n    if (!skipTransform) {\n      return this._transformedRect(rect, relativeTo);\n    }\n    return rect;\n  }\n  drawScene(can, top, bufferCanvas) {\n    const layer = this.getLayer();\n    const canvas = can || layer.getCanvas(),\n      context = canvas.getContext(),\n      cachedCanvas = this._getCanvasCache(),\n      drawFunc = this.getSceneFunc(),\n      hasShadow = this.hasShadow();\n    let stage;\n    const skipBuffer = false;\n    const cachingSelf = top === this;\n    if (!this.isVisible() && !cachingSelf) {\n      return this;\n    }\n    if (cachedCanvas) {\n      context.save();\n      const m = this.getAbsoluteTransform(top).getMatrix();\n      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n      this._drawCachedSceneCanvas(context);\n      context.restore();\n      return this;\n    }\n    if (!drawFunc) {\n      return this;\n    }\n    context.save();\n    if (this._useBufferCanvas() && !skipBuffer) {\n      stage = this.getStage();\n      const bc = bufferCanvas || stage.bufferCanvas;\n      const bufferContext = bc.getContext();\n      bufferContext.clear();\n      bufferContext.save();\n      bufferContext._applyLineJoin(this);\n      bufferContext._applyMiterLimit(this);\n      const o = this.getAbsoluteTransform(top).getMatrix();\n      bufferContext.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n      drawFunc.call(this, bufferContext, this);\n      bufferContext.restore();\n      const ratio = bc.pixelRatio;\n      if (hasShadow) {\n        context._applyShadow(this);\n      }\n      context._applyOpacity(this);\n      context._applyGlobalCompositeOperation(this);\n      context.drawImage(bc._canvas, bc.x || 0, bc.y || 0, bc.width / ratio, bc.height / ratio);\n    } else {\n      context._applyLineJoin(this);\n      context._applyMiterLimit(this);\n      if (!cachingSelf) {\n        const o = this.getAbsoluteTransform(top).getMatrix();\n        context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n        context._applyOpacity(this);\n        context._applyGlobalCompositeOperation(this);\n      }\n      if (hasShadow) {\n        context._applyShadow(this);\n      }\n      drawFunc.call(this, context, this);\n    }\n    context.restore();\n    return this;\n  }\n  drawHit(can, top) {\n    let skipDragCheck = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!this.shouldDrawHit(top, skipDragCheck)) {\n      return this;\n    }\n    const layer = this.getLayer(),\n      canvas = can || layer.hitCanvas,\n      context = canvas && canvas.getContext(),\n      drawFunc = this.hitFunc() || this.sceneFunc(),\n      cachedCanvas = this._getCanvasCache(),\n      cachedHitCanvas = cachedCanvas && cachedCanvas.hit;\n    if (!this.colorKey) {\n      Util.warn('Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()');\n    }\n    if (cachedHitCanvas) {\n      context.save();\n      const m = this.getAbsoluteTransform(top).getMatrix();\n      context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\n      this._drawCachedHitCanvas(context);\n      context.restore();\n      return this;\n    }\n    if (!drawFunc) {\n      return this;\n    }\n    context.save();\n    context._applyLineJoin(this);\n    context._applyMiterLimit(this);\n    const selfCache = this === top;\n    if (!selfCache) {\n      const o = this.getAbsoluteTransform(top).getMatrix();\n      context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\n    }\n    drawFunc.call(this, context, this);\n    context.restore();\n    return this;\n  }\n  drawHitFromCache() {\n    let alphaThreshold = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    const cachedCanvas = this._getCanvasCache(),\n      sceneCanvas = this._getCachedSceneCanvas(),\n      hitCanvas = cachedCanvas.hit,\n      hitContext = hitCanvas.getContext(),\n      hitWidth = hitCanvas.getWidth(),\n      hitHeight = hitCanvas.getHeight();\n    hitContext.clear();\n    hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);\n    try {\n      const hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);\n      const hitData = hitImageData.data;\n      const len = hitData.length;\n      const rgbColorKey = Util._hexToRgb(this.colorKey);\n      for (let i = 0; i < len; i += 4) {\n        const alpha = hitData[i + 3];\n        if (alpha > alphaThreshold) {\n          hitData[i] = rgbColorKey.r;\n          hitData[i + 1] = rgbColorKey.g;\n          hitData[i + 2] = rgbColorKey.b;\n          hitData[i + 3] = 255;\n        } else {\n          hitData[i + 3] = 0;\n        }\n      }\n      hitContext.putImageData(hitImageData, 0, 0);\n    } catch (e) {\n      Util.error('Unable to draw hit graph from cached scene canvas. ' + e.message);\n    }\n    return this;\n  }\n  hasPointerCapture(pointerId) {\n    return PointerEvents.hasPointerCapture(pointerId, this);\n  }\n  setPointerCapture(pointerId) {\n    PointerEvents.setPointerCapture(pointerId, this);\n  }\n  releaseCapture(pointerId) {\n    PointerEvents.releaseCapture(pointerId, this);\n  }\n}\nShape.prototype._fillFunc = _fillFunc;\nShape.prototype._strokeFunc = _strokeFunc;\nShape.prototype._fillFuncHit = _fillFuncHit;\nShape.prototype._strokeFuncHit = _strokeFuncHit;\nShape.prototype._centroid = false;\nShape.prototype.nodeType = 'Shape';\n_registerNode(Shape);\nShape.prototype.eventListeners = {};\nShape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearHasShadowCache);\nShape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearGetShadowRGBACache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva', _clearFillPatternCache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva', _clearLinearGradientCache);\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva', _clearRadialGradientCache);\nFactory.addGetterSetter(Shape, 'stroke', undefined, getStringOrGradientValidator());\nFactory.addGetterSetter(Shape, 'strokeWidth', 2, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillAfterStrokeEnabled', false);\nFactory.addGetterSetter(Shape, 'hitStrokeWidth', 'auto', getNumberOrAutoValidator());\nFactory.addGetterSetter(Shape, 'strokeHitEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Shape, 'perfectDrawEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Shape, 'shadowForStrokeEnabled', true, getBooleanValidator());\nFactory.addGetterSetter(Shape, 'lineJoin');\nFactory.addGetterSetter(Shape, 'lineCap');\nFactory.addGetterSetter(Shape, 'miterLimit');\nFactory.addGetterSetter(Shape, 'sceneFunc');\nFactory.addGetterSetter(Shape, 'hitFunc');\nFactory.addGetterSetter(Shape, 'dash');\nFactory.addGetterSetter(Shape, 'dashOffset', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'shadowColor', undefined, getStringValidator());\nFactory.addGetterSetter(Shape, 'shadowBlur', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'shadowOpacity', 1, getNumberValidator());\nFactory.addComponentsGetterSetter(Shape, 'shadowOffset', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'shadowOffsetX', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'shadowOffsetY', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternImage');\nFactory.addGetterSetter(Shape, 'fill', undefined, getStringOrGradientValidator());\nFactory.addGetterSetter(Shape, 'fillPatternX', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternY', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillLinearGradientColorStops');\nFactory.addGetterSetter(Shape, 'strokeLinearGradientColorStops');\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartRadius', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndRadius', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientColorStops');\nFactory.addGetterSetter(Shape, 'fillPatternRepeat', 'repeat');\nFactory.addGetterSetter(Shape, 'fillEnabled', true);\nFactory.addGetterSetter(Shape, 'strokeEnabled', true);\nFactory.addGetterSetter(Shape, 'shadowEnabled', true);\nFactory.addGetterSetter(Shape, 'dashEnabled', true);\nFactory.addGetterSetter(Shape, 'strokeScaleEnabled', true);\nFactory.addGetterSetter(Shape, 'fillPriority', 'color');\nFactory.addComponentsGetterSetter(Shape, 'fillPatternOffset', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillPatternOffsetX', 0, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternOffsetY', 0, getNumberValidator());\nFactory.addComponentsGetterSetter(Shape, 'fillPatternScale', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillPatternScaleX', 1, getNumberValidator());\nFactory.addGetterSetter(Shape, 'fillPatternScaleY', 1, getNumberValidator());\nFactory.addComponentsGetterSetter(Shape, 'fillLinearGradientStartPoint', ['x', 'y']);\nFactory.addComponentsGetterSetter(Shape, 'strokeLinearGradientStartPoint', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillLinearGradientStartPointX', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientStartPointX', 0);\nFactory.addGetterSetter(Shape, 'fillLinearGradientStartPointY', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientStartPointY', 0);\nFactory.addComponentsGetterSetter(Shape, 'fillLinearGradientEndPoint', ['x', 'y']);\nFactory.addComponentsGetterSetter(Shape, 'strokeLinearGradientEndPoint', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillLinearGradientEndPointX', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientEndPointX', 0);\nFactory.addGetterSetter(Shape, 'fillLinearGradientEndPointY', 0);\nFactory.addGetterSetter(Shape, 'strokeLinearGradientEndPointY', 0);\nFactory.addComponentsGetterSetter(Shape, 'fillRadialGradientStartPoint', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartPointX', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartPointY', 0);\nFactory.addComponentsGetterSetter(Shape, 'fillRadialGradientEndPoint', ['x', 'y']);\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndPointX', 0);\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndPointY', 0);\nFactory.addGetterSetter(Shape, 'fillPatternRotation', 0);\nFactory.addGetterSetter(Shape, 'fillRule', undefined, getStringValidator());\nFactory.backCompat(Shape, {\n  dashArray: 'dash',\n  getDashArray: 'getDash',\n  setDashArray: 'getDash',\n  drawFunc: 'sceneFunc',\n  getDrawFunc: 'getSceneFunc',\n  setDrawFunc: 'setSceneFunc',\n  drawHitFunc: 'hitFunc',\n  getDrawHitFunc: 'getHitFunc',\n  setDrawHitFunc: 'setHitFunc'\n});","map":{"version":3,"names":["Konva","Transform","Util","Factory","Node","getNumberValidator","getNumberOrAutoValidator","getStringValidator","getBooleanValidator","getStringOrGradientValidator","_registerNode","PointerEvents","HAS_SHADOW","SHADOW_RGBA","patternImage","linearGradient","radialGradient","dummyContext","getDummyContext","createCanvasElement","getContext","shapes","_fillFunc","context","fillRule","attrs","fill","_strokeFunc","stroke","_fillFuncHit","_strokeFuncHit","_clearHasShadowCache","_clearCache","_clearGetShadowRGBACache","_clearFillPatternCache","_clearLinearGradientCache","_clearRadialGradientCache","Shape","constructor","config","key","getRandomColor","colorKey","warn","getLayer","getCanvas","getSceneFunc","sceneFunc","getHitFunc","hitFunc","hasShadow","_getCache","_hasShadow","shadowEnabled","shadowOpacity","shadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","_getFillPattern","__getFillPattern","fillPatternImage","ctx","pattern","createPattern","fillPatternRepeat","setTransform","tr","translate","fillPatternX","fillPatternY","rotate","getAngle","fillPatternRotation","scale","fillPatternScaleX","fillPatternScaleY","fillPatternOffsetX","fillPatternOffsetY","m","getMatrix","matrix","DOMMatrix","a","b","c","d","e","f","_getLinearGradient","__getLinearGradient","colorStops","fillLinearGradientColorStops","start","fillLinearGradientStartPoint","end","fillLinearGradientEndPoint","grd","createLinearGradient","x","y","n","length","addColorStop","_getRadialGradient","__getRadialGradient","fillRadialGradientColorStops","fillRadialGradientStartPoint","fillRadialGradientEndPoint","createRadialGradient","fillRadialGradientStartRadius","fillRadialGradientEndRadius","getShadowRGBA","_getShadowRGBA","rgba","colorToRGBA","r","g","hasFill","_calculate","fillEnabled","hasStroke","strokeEnabled","strokeWidth","strokeLinearGradientColorStops","hasHitStroke","width","hitStrokeWidth","intersects","point","stage","getStage","bufferHitCanvas","clear","drawHit","undefined","p","getImageData","Math","round","data","destroy","prototype","call","_useBufferCanvas","forceFill","_a","perfectDrawEnabled","isTransparent","getAbsoluteOpacity","strokeForShadow","shadowForStrokeEnabled","setStrokeHitEnabled","val","getStrokeHitEnabled","getSelfRect","size","_centroid","height","getClientRect","arguments","hasCachedParent","parent","getParent","isCached","skipTransform","relativeTo","fillRect","applyStroke","skipStroke","fillAndStrokeWidth","fillAndStrokeHeight","applyShadow","skipShadow","preWidth","abs","preHeight","blurRadius","rect","min","_transformedRect","drawScene","can","top","bufferCanvas","layer","canvas","cachedCanvas","_getCanvasCache","drawFunc","skipBuffer","cachingSelf","isVisible","save","getAbsoluteTransform","transform","_drawCachedSceneCanvas","restore","bc","bufferContext","_applyLineJoin","_applyMiterLimit","o","ratio","pixelRatio","_applyShadow","_applyOpacity","_applyGlobalCompositeOperation","drawImage","_canvas","skipDragCheck","shouldDrawHit","hitCanvas","cachedHitCanvas","hit","_drawCachedHitCanvas","selfCache","drawHitFromCache","alphaThreshold","sceneCanvas","_getCachedSceneCanvas","hitContext","hitWidth","getWidth","hitHeight","getHeight","hitImageData","hitData","len","rgbColorKey","_hexToRgb","i","alpha","putImageData","error","message","hasPointerCapture","pointerId","setPointerCapture","releaseCapture","nodeType","eventListeners","on","addGetterSetter","addComponentsGetterSetter","backCompat","dashArray","getDashArray","setDashArray","getDrawFunc","setDrawFunc","drawHitFunc","getDrawHitFunc","setDrawHitFunc"],"sources":["C:/Users/lenovo pro/Documents/gncipl-6-week/Week-6_final_project/matty-project/client/node_modules/konva/lib/Shape.js"],"sourcesContent":["import { Konva } from \"./Global.js\";\r\nimport { Transform, Util } from \"./Util.js\";\r\nimport { Factory } from \"./Factory.js\";\r\nimport { Node } from \"./Node.js\";\r\nimport { getNumberValidator, getNumberOrAutoValidator, getStringValidator, getBooleanValidator, getStringOrGradientValidator, } from \"./Validators.js\";\r\nimport { _registerNode } from \"./Global.js\";\r\nimport * as PointerEvents from \"./PointerEvents.js\";\r\nconst HAS_SHADOW = 'hasShadow';\r\nconst SHADOW_RGBA = 'shadowRGBA';\r\nconst patternImage = 'patternImage';\r\nconst linearGradient = 'linearGradient';\r\nconst radialGradient = 'radialGradient';\r\nlet dummyContext;\r\nfunction getDummyContext() {\r\n    if (dummyContext) {\r\n        return dummyContext;\r\n    }\r\n    dummyContext = Util.createCanvasElement().getContext('2d');\r\n    return dummyContext;\r\n}\r\nexport const shapes = {};\r\nfunction _fillFunc(context) {\r\n    const fillRule = this.attrs.fillRule;\r\n    if (fillRule) {\r\n        context.fill(fillRule);\r\n    }\r\n    else {\r\n        context.fill();\r\n    }\r\n}\r\nfunction _strokeFunc(context) {\r\n    context.stroke();\r\n}\r\nfunction _fillFuncHit(context) {\r\n    const fillRule = this.attrs.fillRule;\r\n    if (fillRule) {\r\n        context.fill(fillRule);\r\n    }\r\n    else {\r\n        context.fill();\r\n    }\r\n}\r\nfunction _strokeFuncHit(context) {\r\n    context.stroke();\r\n}\r\nfunction _clearHasShadowCache() {\r\n    this._clearCache(HAS_SHADOW);\r\n}\r\nfunction _clearGetShadowRGBACache() {\r\n    this._clearCache(SHADOW_RGBA);\r\n}\r\nfunction _clearFillPatternCache() {\r\n    this._clearCache(patternImage);\r\n}\r\nfunction _clearLinearGradientCache() {\r\n    this._clearCache(linearGradient);\r\n}\r\nfunction _clearRadialGradientCache() {\r\n    this._clearCache(radialGradient);\r\n}\r\nexport class Shape extends Node {\r\n    constructor(config) {\r\n        super(config);\r\n        let key;\r\n        while (true) {\r\n            key = Util.getRandomColor();\r\n            if (key && !(key in shapes)) {\r\n                break;\r\n            }\r\n        }\r\n        this.colorKey = key;\r\n        shapes[key] = this;\r\n    }\r\n    getContext() {\r\n        Util.warn('shape.getContext() method is deprecated. Please do not use it.');\r\n        return this.getLayer().getContext();\r\n    }\r\n    getCanvas() {\r\n        Util.warn('shape.getCanvas() method is deprecated. Please do not use it.');\r\n        return this.getLayer().getCanvas();\r\n    }\r\n    getSceneFunc() {\r\n        return this.attrs.sceneFunc || this['_sceneFunc'];\r\n    }\r\n    getHitFunc() {\r\n        return this.attrs.hitFunc || this['_hitFunc'];\r\n    }\r\n    hasShadow() {\r\n        return this._getCache(HAS_SHADOW, this._hasShadow);\r\n    }\r\n    _hasShadow() {\r\n        return (this.shadowEnabled() &&\r\n            this.shadowOpacity() !== 0 &&\r\n            !!(this.shadowColor() ||\r\n                this.shadowBlur() ||\r\n                this.shadowOffsetX() ||\r\n                this.shadowOffsetY()));\r\n    }\r\n    _getFillPattern() {\r\n        return this._getCache(patternImage, this.__getFillPattern);\r\n    }\r\n    __getFillPattern() {\r\n        if (this.fillPatternImage()) {\r\n            const ctx = getDummyContext();\r\n            const pattern = ctx.createPattern(this.fillPatternImage(), this.fillPatternRepeat() || 'repeat');\r\n            if (pattern && pattern.setTransform) {\r\n                const tr = new Transform();\r\n                tr.translate(this.fillPatternX(), this.fillPatternY());\r\n                tr.rotate(Konva.getAngle(this.fillPatternRotation()));\r\n                tr.scale(this.fillPatternScaleX(), this.fillPatternScaleY());\r\n                tr.translate(-1 * this.fillPatternOffsetX(), -1 * this.fillPatternOffsetY());\r\n                const m = tr.getMatrix();\r\n                const matrix = typeof DOMMatrix === 'undefined'\r\n                    ? {\r\n                        a: m[0],\r\n                        b: m[1],\r\n                        c: m[2],\r\n                        d: m[3],\r\n                        e: m[4],\r\n                        f: m[5],\r\n                    }\r\n                    : new DOMMatrix(m);\r\n                pattern.setTransform(matrix);\r\n            }\r\n            return pattern;\r\n        }\r\n    }\r\n    _getLinearGradient() {\r\n        return this._getCache(linearGradient, this.__getLinearGradient);\r\n    }\r\n    __getLinearGradient() {\r\n        const colorStops = this.fillLinearGradientColorStops();\r\n        if (colorStops) {\r\n            const ctx = getDummyContext();\r\n            const start = this.fillLinearGradientStartPoint();\r\n            const end = this.fillLinearGradientEndPoint();\r\n            const grd = ctx.createLinearGradient(start.x, start.y, end.x, end.y);\r\n            for (let n = 0; n < colorStops.length; n += 2) {\r\n                grd.addColorStop(colorStops[n], colorStops[n + 1]);\r\n            }\r\n            return grd;\r\n        }\r\n    }\r\n    _getRadialGradient() {\r\n        return this._getCache(radialGradient, this.__getRadialGradient);\r\n    }\r\n    __getRadialGradient() {\r\n        const colorStops = this.fillRadialGradientColorStops();\r\n        if (colorStops) {\r\n            const ctx = getDummyContext();\r\n            const start = this.fillRadialGradientStartPoint();\r\n            const end = this.fillRadialGradientEndPoint();\r\n            const grd = ctx.createRadialGradient(start.x, start.y, this.fillRadialGradientStartRadius(), end.x, end.y, this.fillRadialGradientEndRadius());\r\n            for (let n = 0; n < colorStops.length; n += 2) {\r\n                grd.addColorStop(colorStops[n], colorStops[n + 1]);\r\n            }\r\n            return grd;\r\n        }\r\n    }\r\n    getShadowRGBA() {\r\n        return this._getCache(SHADOW_RGBA, this._getShadowRGBA);\r\n    }\r\n    _getShadowRGBA() {\r\n        if (!this.hasShadow()) {\r\n            return;\r\n        }\r\n        const rgba = Util.colorToRGBA(this.shadowColor());\r\n        if (rgba) {\r\n            return ('rgba(' +\r\n                rgba.r +\r\n                ',' +\r\n                rgba.g +\r\n                ',' +\r\n                rgba.b +\r\n                ',' +\r\n                rgba.a * (this.shadowOpacity() || 1) +\r\n                ')');\r\n        }\r\n    }\r\n    hasFill() {\r\n        return this._calculate('hasFill', [\r\n            'fillEnabled',\r\n            'fill',\r\n            'fillPatternImage',\r\n            'fillLinearGradientColorStops',\r\n            'fillRadialGradientColorStops',\r\n        ], () => {\r\n            return (this.fillEnabled() &&\r\n                !!(this.fill() ||\r\n                    this.fillPatternImage() ||\r\n                    this.fillLinearGradientColorStops() ||\r\n                    this.fillRadialGradientColorStops()));\r\n        });\r\n    }\r\n    hasStroke() {\r\n        return this._calculate('hasStroke', [\r\n            'strokeEnabled',\r\n            'strokeWidth',\r\n            'stroke',\r\n            'strokeLinearGradientColorStops',\r\n        ], () => {\r\n            return (this.strokeEnabled() &&\r\n                this.strokeWidth() &&\r\n                !!(this.stroke() || this.strokeLinearGradientColorStops()));\r\n        });\r\n    }\r\n    hasHitStroke() {\r\n        const width = this.hitStrokeWidth();\r\n        if (width === 'auto') {\r\n            return this.hasStroke();\r\n        }\r\n        return this.strokeEnabled() && !!width;\r\n    }\r\n    intersects(point) {\r\n        const stage = this.getStage();\r\n        if (!stage) {\r\n            return false;\r\n        }\r\n        const bufferHitCanvas = stage.bufferHitCanvas;\r\n        bufferHitCanvas.getContext().clear();\r\n        this.drawHit(bufferHitCanvas, undefined, true);\r\n        const p = bufferHitCanvas.context.getImageData(Math.round(point.x), Math.round(point.y), 1, 1).data;\r\n        return p[3] > 0;\r\n    }\r\n    destroy() {\r\n        Node.prototype.destroy.call(this);\r\n        delete shapes[this.colorKey];\r\n        delete this.colorKey;\r\n        return this;\r\n    }\r\n    _useBufferCanvas(forceFill) {\r\n        var _a;\r\n        const perfectDrawEnabled = (_a = this.attrs.perfectDrawEnabled) !== null && _a !== void 0 ? _a : true;\r\n        if (!perfectDrawEnabled) {\r\n            return false;\r\n        }\r\n        const hasFill = forceFill || this.hasFill();\r\n        const hasStroke = this.hasStroke();\r\n        const isTransparent = this.getAbsoluteOpacity() !== 1;\r\n        if (hasFill && hasStroke && isTransparent) {\r\n            return true;\r\n        }\r\n        const hasShadow = this.hasShadow();\r\n        const strokeForShadow = this.shadowForStrokeEnabled();\r\n        if (hasFill && hasStroke && hasShadow && strokeForShadow) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    setStrokeHitEnabled(val) {\r\n        Util.warn('strokeHitEnabled property is deprecated. Please use hitStrokeWidth instead.');\r\n        if (val) {\r\n            this.hitStrokeWidth('auto');\r\n        }\r\n        else {\r\n            this.hitStrokeWidth(0);\r\n        }\r\n    }\r\n    getStrokeHitEnabled() {\r\n        if (this.hitStrokeWidth() === 0) {\r\n            return false;\r\n        }\r\n        else {\r\n            return true;\r\n        }\r\n    }\r\n    getSelfRect() {\r\n        const size = this.size();\r\n        return {\r\n            x: this._centroid ? -size.width / 2 : 0,\r\n            y: this._centroid ? -size.height / 2 : 0,\r\n            width: size.width,\r\n            height: size.height,\r\n        };\r\n    }\r\n    getClientRect(config = {}) {\r\n        let hasCachedParent = false;\r\n        let parent = this.getParent();\r\n        while (parent) {\r\n            if (parent.isCached()) {\r\n                hasCachedParent = true;\r\n                break;\r\n            }\r\n            parent = parent.getParent();\r\n        }\r\n        const skipTransform = config.skipTransform;\r\n        const relativeTo = config.relativeTo || (hasCachedParent && this.getStage()) || undefined;\r\n        const fillRect = this.getSelfRect();\r\n        const applyStroke = !config.skipStroke && this.hasStroke();\r\n        const strokeWidth = (applyStroke && this.strokeWidth()) || 0;\r\n        const fillAndStrokeWidth = fillRect.width + strokeWidth;\r\n        const fillAndStrokeHeight = fillRect.height + strokeWidth;\r\n        const applyShadow = !config.skipShadow && this.hasShadow();\r\n        const shadowOffsetX = applyShadow ? this.shadowOffsetX() : 0;\r\n        const shadowOffsetY = applyShadow ? this.shadowOffsetY() : 0;\r\n        const preWidth = fillAndStrokeWidth + Math.abs(shadowOffsetX);\r\n        const preHeight = fillAndStrokeHeight + Math.abs(shadowOffsetY);\r\n        const blurRadius = (applyShadow && this.shadowBlur()) || 0;\r\n        const width = preWidth + blurRadius * 2;\r\n        const height = preHeight + blurRadius * 2;\r\n        const rect = {\r\n            width: width,\r\n            height: height,\r\n            x: -(strokeWidth / 2 + blurRadius) +\r\n                Math.min(shadowOffsetX, 0) +\r\n                fillRect.x,\r\n            y: -(strokeWidth / 2 + blurRadius) +\r\n                Math.min(shadowOffsetY, 0) +\r\n                fillRect.y,\r\n        };\r\n        if (!skipTransform) {\r\n            return this._transformedRect(rect, relativeTo);\r\n        }\r\n        return rect;\r\n    }\r\n    drawScene(can, top, bufferCanvas) {\r\n        const layer = this.getLayer();\r\n        const canvas = can || layer.getCanvas(), context = canvas.getContext(), cachedCanvas = this._getCanvasCache(), drawFunc = this.getSceneFunc(), hasShadow = this.hasShadow();\r\n        let stage;\r\n        const skipBuffer = false;\r\n        const cachingSelf = top === this;\r\n        if (!this.isVisible() && !cachingSelf) {\r\n            return this;\r\n        }\r\n        if (cachedCanvas) {\r\n            context.save();\r\n            const m = this.getAbsoluteTransform(top).getMatrix();\r\n            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\r\n            this._drawCachedSceneCanvas(context);\r\n            context.restore();\r\n            return this;\r\n        }\r\n        if (!drawFunc) {\r\n            return this;\r\n        }\r\n        context.save();\r\n        if (this._useBufferCanvas() && !skipBuffer) {\r\n            stage = this.getStage();\r\n            const bc = bufferCanvas || stage.bufferCanvas;\r\n            const bufferContext = bc.getContext();\r\n            bufferContext.clear();\r\n            bufferContext.save();\r\n            bufferContext._applyLineJoin(this);\r\n            bufferContext._applyMiterLimit(this);\r\n            const o = this.getAbsoluteTransform(top).getMatrix();\r\n            bufferContext.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\r\n            drawFunc.call(this, bufferContext, this);\r\n            bufferContext.restore();\r\n            const ratio = bc.pixelRatio;\r\n            if (hasShadow) {\r\n                context._applyShadow(this);\r\n            }\r\n            context._applyOpacity(this);\r\n            context._applyGlobalCompositeOperation(this);\r\n            context.drawImage(bc._canvas, bc.x || 0, bc.y || 0, bc.width / ratio, bc.height / ratio);\r\n        }\r\n        else {\r\n            context._applyLineJoin(this);\r\n            context._applyMiterLimit(this);\r\n            if (!cachingSelf) {\r\n                const o = this.getAbsoluteTransform(top).getMatrix();\r\n                context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\r\n                context._applyOpacity(this);\r\n                context._applyGlobalCompositeOperation(this);\r\n            }\r\n            if (hasShadow) {\r\n                context._applyShadow(this);\r\n            }\r\n            drawFunc.call(this, context, this);\r\n        }\r\n        context.restore();\r\n        return this;\r\n    }\r\n    drawHit(can, top, skipDragCheck = false) {\r\n        if (!this.shouldDrawHit(top, skipDragCheck)) {\r\n            return this;\r\n        }\r\n        const layer = this.getLayer(), canvas = can || layer.hitCanvas, context = canvas && canvas.getContext(), drawFunc = this.hitFunc() || this.sceneFunc(), cachedCanvas = this._getCanvasCache(), cachedHitCanvas = cachedCanvas && cachedCanvas.hit;\r\n        if (!this.colorKey) {\r\n            Util.warn('Looks like your canvas has a destroyed shape in it. Do not reuse shape after you destroyed it. If you want to reuse shape you should call remove() instead of destroy()');\r\n        }\r\n        if (cachedHitCanvas) {\r\n            context.save();\r\n            const m = this.getAbsoluteTransform(top).getMatrix();\r\n            context.transform(m[0], m[1], m[2], m[3], m[4], m[5]);\r\n            this._drawCachedHitCanvas(context);\r\n            context.restore();\r\n            return this;\r\n        }\r\n        if (!drawFunc) {\r\n            return this;\r\n        }\r\n        context.save();\r\n        context._applyLineJoin(this);\r\n        context._applyMiterLimit(this);\r\n        const selfCache = this === top;\r\n        if (!selfCache) {\r\n            const o = this.getAbsoluteTransform(top).getMatrix();\r\n            context.transform(o[0], o[1], o[2], o[3], o[4], o[5]);\r\n        }\r\n        drawFunc.call(this, context, this);\r\n        context.restore();\r\n        return this;\r\n    }\r\n    drawHitFromCache(alphaThreshold = 0) {\r\n        const cachedCanvas = this._getCanvasCache(), sceneCanvas = this._getCachedSceneCanvas(), hitCanvas = cachedCanvas.hit, hitContext = hitCanvas.getContext(), hitWidth = hitCanvas.getWidth(), hitHeight = hitCanvas.getHeight();\r\n        hitContext.clear();\r\n        hitContext.drawImage(sceneCanvas._canvas, 0, 0, hitWidth, hitHeight);\r\n        try {\r\n            const hitImageData = hitContext.getImageData(0, 0, hitWidth, hitHeight);\r\n            const hitData = hitImageData.data;\r\n            const len = hitData.length;\r\n            const rgbColorKey = Util._hexToRgb(this.colorKey);\r\n            for (let i = 0; i < len; i += 4) {\r\n                const alpha = hitData[i + 3];\r\n                if (alpha > alphaThreshold) {\r\n                    hitData[i] = rgbColorKey.r;\r\n                    hitData[i + 1] = rgbColorKey.g;\r\n                    hitData[i + 2] = rgbColorKey.b;\r\n                    hitData[i + 3] = 255;\r\n                }\r\n                else {\r\n                    hitData[i + 3] = 0;\r\n                }\r\n            }\r\n            hitContext.putImageData(hitImageData, 0, 0);\r\n        }\r\n        catch (e) {\r\n            Util.error('Unable to draw hit graph from cached scene canvas. ' + e.message);\r\n        }\r\n        return this;\r\n    }\r\n    hasPointerCapture(pointerId) {\r\n        return PointerEvents.hasPointerCapture(pointerId, this);\r\n    }\r\n    setPointerCapture(pointerId) {\r\n        PointerEvents.setPointerCapture(pointerId, this);\r\n    }\r\n    releaseCapture(pointerId) {\r\n        PointerEvents.releaseCapture(pointerId, this);\r\n    }\r\n}\r\nShape.prototype._fillFunc = _fillFunc;\r\nShape.prototype._strokeFunc = _strokeFunc;\r\nShape.prototype._fillFuncHit = _fillFuncHit;\r\nShape.prototype._strokeFuncHit = _strokeFuncHit;\r\nShape.prototype._centroid = false;\r\nShape.prototype.nodeType = 'Shape';\r\n_registerNode(Shape);\r\nShape.prototype.eventListeners = {};\r\nShape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowBlurChange.konva shadowOffsetChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearHasShadowCache);\r\nShape.prototype.on.call(Shape.prototype, 'shadowColorChange.konva shadowOpacityChange.konva shadowEnabledChange.konva', _clearGetShadowRGBACache);\r\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillPatternImageChange.konva fillPatternRepeatChange.konva fillPatternScaleXChange.konva fillPatternScaleYChange.konva fillPatternOffsetXChange.konva fillPatternOffsetYChange.konva fillPatternXChange.konva fillPatternYChange.konva fillPatternRotationChange.konva', _clearFillPatternCache);\r\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillLinearGradientColorStopsChange.konva fillLinearGradientStartPointXChange.konva fillLinearGradientStartPointYChange.konva fillLinearGradientEndPointXChange.konva fillLinearGradientEndPointYChange.konva', _clearLinearGradientCache);\r\nShape.prototype.on.call(Shape.prototype, 'fillPriorityChange.konva fillRadialGradientColorStopsChange.konva fillRadialGradientStartPointXChange.konva fillRadialGradientStartPointYChange.konva fillRadialGradientEndPointXChange.konva fillRadialGradientEndPointYChange.konva fillRadialGradientStartRadiusChange.konva fillRadialGradientEndRadiusChange.konva', _clearRadialGradientCache);\r\nFactory.addGetterSetter(Shape, 'stroke', undefined, getStringOrGradientValidator());\r\nFactory.addGetterSetter(Shape, 'strokeWidth', 2, getNumberValidator());\r\nFactory.addGetterSetter(Shape, 'fillAfterStrokeEnabled', false);\r\nFactory.addGetterSetter(Shape, 'hitStrokeWidth', 'auto', getNumberOrAutoValidator());\r\nFactory.addGetterSetter(Shape, 'strokeHitEnabled', true, getBooleanValidator());\r\nFactory.addGetterSetter(Shape, 'perfectDrawEnabled', true, getBooleanValidator());\r\nFactory.addGetterSetter(Shape, 'shadowForStrokeEnabled', true, getBooleanValidator());\r\nFactory.addGetterSetter(Shape, 'lineJoin');\r\nFactory.addGetterSetter(Shape, 'lineCap');\r\nFactory.addGetterSetter(Shape, 'miterLimit');\r\nFactory.addGetterSetter(Shape, 'sceneFunc');\r\nFactory.addGetterSetter(Shape, 'hitFunc');\r\nFactory.addGetterSetter(Shape, 'dash');\r\nFactory.addGetterSetter(Shape, 'dashOffset', 0, getNumberValidator());\r\nFactory.addGetterSetter(Shape, 'shadowColor', undefined, getStringValidator());\r\nFactory.addGetterSetter(Shape, 'shadowBlur', 0, getNumberValidator());\r\nFactory.addGetterSetter(Shape, 'shadowOpacity', 1, getNumberValidator());\r\nFactory.addComponentsGetterSetter(Shape, 'shadowOffset', ['x', 'y']);\r\nFactory.addGetterSetter(Shape, 'shadowOffsetX', 0, getNumberValidator());\r\nFactory.addGetterSetter(Shape, 'shadowOffsetY', 0, getNumberValidator());\r\nFactory.addGetterSetter(Shape, 'fillPatternImage');\r\nFactory.addGetterSetter(Shape, 'fill', undefined, getStringOrGradientValidator());\r\nFactory.addGetterSetter(Shape, 'fillPatternX', 0, getNumberValidator());\r\nFactory.addGetterSetter(Shape, 'fillPatternY', 0, getNumberValidator());\r\nFactory.addGetterSetter(Shape, 'fillLinearGradientColorStops');\r\nFactory.addGetterSetter(Shape, 'strokeLinearGradientColorStops');\r\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartRadius', 0);\r\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndRadius', 0);\r\nFactory.addGetterSetter(Shape, 'fillRadialGradientColorStops');\r\nFactory.addGetterSetter(Shape, 'fillPatternRepeat', 'repeat');\r\nFactory.addGetterSetter(Shape, 'fillEnabled', true);\r\nFactory.addGetterSetter(Shape, 'strokeEnabled', true);\r\nFactory.addGetterSetter(Shape, 'shadowEnabled', true);\r\nFactory.addGetterSetter(Shape, 'dashEnabled', true);\r\nFactory.addGetterSetter(Shape, 'strokeScaleEnabled', true);\r\nFactory.addGetterSetter(Shape, 'fillPriority', 'color');\r\nFactory.addComponentsGetterSetter(Shape, 'fillPatternOffset', ['x', 'y']);\r\nFactory.addGetterSetter(Shape, 'fillPatternOffsetX', 0, getNumberValidator());\r\nFactory.addGetterSetter(Shape, 'fillPatternOffsetY', 0, getNumberValidator());\r\nFactory.addComponentsGetterSetter(Shape, 'fillPatternScale', ['x', 'y']);\r\nFactory.addGetterSetter(Shape, 'fillPatternScaleX', 1, getNumberValidator());\r\nFactory.addGetterSetter(Shape, 'fillPatternScaleY', 1, getNumberValidator());\r\nFactory.addComponentsGetterSetter(Shape, 'fillLinearGradientStartPoint', [\r\n    'x',\r\n    'y',\r\n]);\r\nFactory.addComponentsGetterSetter(Shape, 'strokeLinearGradientStartPoint', [\r\n    'x',\r\n    'y',\r\n]);\r\nFactory.addGetterSetter(Shape, 'fillLinearGradientStartPointX', 0);\r\nFactory.addGetterSetter(Shape, 'strokeLinearGradientStartPointX', 0);\r\nFactory.addGetterSetter(Shape, 'fillLinearGradientStartPointY', 0);\r\nFactory.addGetterSetter(Shape, 'strokeLinearGradientStartPointY', 0);\r\nFactory.addComponentsGetterSetter(Shape, 'fillLinearGradientEndPoint', [\r\n    'x',\r\n    'y',\r\n]);\r\nFactory.addComponentsGetterSetter(Shape, 'strokeLinearGradientEndPoint', [\r\n    'x',\r\n    'y',\r\n]);\r\nFactory.addGetterSetter(Shape, 'fillLinearGradientEndPointX', 0);\r\nFactory.addGetterSetter(Shape, 'strokeLinearGradientEndPointX', 0);\r\nFactory.addGetterSetter(Shape, 'fillLinearGradientEndPointY', 0);\r\nFactory.addGetterSetter(Shape, 'strokeLinearGradientEndPointY', 0);\r\nFactory.addComponentsGetterSetter(Shape, 'fillRadialGradientStartPoint', [\r\n    'x',\r\n    'y',\r\n]);\r\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartPointX', 0);\r\nFactory.addGetterSetter(Shape, 'fillRadialGradientStartPointY', 0);\r\nFactory.addComponentsGetterSetter(Shape, 'fillRadialGradientEndPoint', [\r\n    'x',\r\n    'y',\r\n]);\r\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndPointX', 0);\r\nFactory.addGetterSetter(Shape, 'fillRadialGradientEndPointY', 0);\r\nFactory.addGetterSetter(Shape, 'fillPatternRotation', 0);\r\nFactory.addGetterSetter(Shape, 'fillRule', undefined, getStringValidator());\r\nFactory.backCompat(Shape, {\r\n    dashArray: 'dash',\r\n    getDashArray: 'getDash',\r\n    setDashArray: 'getDash',\r\n    drawFunc: 'sceneFunc',\r\n    getDrawFunc: 'getSceneFunc',\r\n    setDrawFunc: 'setSceneFunc',\r\n    drawHitFunc: 'hitFunc',\r\n    getDrawHitFunc: 'getHitFunc',\r\n    setDrawHitFunc: 'setHitFunc',\r\n});\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}