{"ast":null,"code":"var _s = $RefreshSig$();\nimport React, { useRef, useEffect, useState } from 'react';\nfunction drawPolygon(ctx, x, y, radius, sides, color) {\n  ctx.beginPath();\n  for (let i = 0; i < sides; i++) {\n    const angle = 2 * Math.PI * i / sides - Math.PI / 2;\n    const dx = x + radius * Math.cos(angle);\n    const dy = y + radius * Math.sin(angle);\n    if (i === 0) ctx.moveTo(dx, dy);else ctx.lineTo(dx, dy);\n  }\n  ctx.closePath();\n  ctx.fillStyle = color;\n  ctx.fill();\n}\nconst initialState = {\n  shapes: [],\n  texts: [],\n  lines: []\n};\nconst HANDLE_SIZE = 16;\nconst CanvasEditor = () => {\n  _s();\n  const canvasRef = useRef(null);\n  const fileInputRef = useRef(null);\n  const [selectedShape, setSelectedShape] = useState('rectangle');\n  const [shapeColor, setShapeColor] = useState('#4f46e5');\n  const [drawMode, setDrawMode] = useState(false);\n  const [eraserMode, setEraserMode] = useState(false);\n  const [eraserSize, setEraserSize] = useState(20);\n  const [textColor, setTextColor] = useState('#111827');\n  const [pencilColor, setPencilColor] = useState('#333');\n  const [brushSize, setBrushSize] = useState(2);\n  const [dragOffset, setDragOffset] = useState({\n    x: 0,\n    y: 0\n  });\n  const [selectedTextIndex, setSelectedTextIndex] = useState(null);\n  const [selectedShapeIndex, setSelectedShapeIndex] = useState(null);\n  const [isDragging, setIsDragging] = useState(false);\n  const [isDrawing, setIsDrawing] = useState(false);\n  const [resizingHandle, setResizingHandle] = useState(null);\n  const [history, setHistory] = useState([initialState]);\n  const [historyIndex, setHistoryIndex] = useState(0);\n  const drawingPointsRef = useRef([]);\n  const {\n    shapes,\n    texts,\n    lines\n  } = history[historyIndex];\n  const getDefaultSize = type => {\n    if (type === 'rectangle') return {\n      w: 120,\n      h: 80\n    };\n    if (type === 'square' || type === 'circle') return {\n      w: 100,\n      h: 100\n    };\n    if (type === 'oval') return {\n      w: 120,\n      h: 80\n    };\n    if (type === 'image') return {\n      w: 200,\n      h: 200\n    };\n    if (type === 'text') return {\n      w: 120,\n      h: 32\n    };\n    return {\n      w: 120,\n      h: 80\n    };\n  };\n  useEffect(() => {\n    const canvas = canvasRef.current;\n    const ctx = canvas.getContext('2d');\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    ctx.lineWidth = 2;\n    ctx.lineCap = 'round';\n    shapes.forEach((shape, idx) => {\n      var _shape$w, _shape$h;\n      ctx.save();\n      const w = (_shape$w = shape.w) !== null && _shape$w !== void 0 ? _shape$w : getDefaultSize(shape.type).w;\n      const h = (_shape$h = shape.h) !== null && _shape$h !== void 0 ? _shape$h : getDefaultSize(shape.type).h;\n      if (shape.type === 'image') {\n        const img = new window.Image();\n        img.src = shape.src;\n        img.onload = () => {\n          ctx.drawImage(img, shape.x, shape.y, w, h);\n          if (idx === selectedShapeIndex) {\n            ctx.strokeStyle = '#f59e42';\n            ctx.lineWidth = 2;\n            ctx.strokeRect(shape.x - 2, shape.y - 2, w + 4, h + 4);\n            drawHandles(ctx, shape.x, shape.y, w, h);\n          }\n        };\n        if (img.complete) {\n          ctx.drawImage(img, shape.x, shape.y, w, h);\n          if (idx === selectedShapeIndex) {\n            ctx.strokeStyle = '#f59e42';\n            ctx.lineWidth = 2;\n            ctx.strokeRect(shape.x - 2, shape.y - 2, w + 4, h + 4);\n            drawHandles(ctx, shape.x, shape.y, w, h);\n          }\n        }\n      } else {\n        ctx.fillStyle = shape.color;\n        ctx.strokeStyle = shape.color;\n        if (shape.type === 'rectangle' || shape.type === 'square') {\n          ctx.fillRect(shape.x, shape.y, w, h);\n        } else if (shape.type === 'circle') {\n          ctx.beginPath();\n          ctx.arc(shape.x + w / 2, shape.y + h / 2, w / 2, 0, 2 * Math.PI);\n          ctx.fill();\n        } else if (shape.type === 'oval') {\n          ctx.save();\n          ctx.translate(shape.x + w / 2, shape.y + h / 2);\n          ctx.scale(1.5, 1);\n          ctx.beginPath();\n          ctx.arc(0, 0, h / 2, 0, 2 * Math.PI);\n          ctx.restore();\n          ctx.fill();\n        } else if (shape.type === 'triangle') {\n          ctx.beginPath();\n          ctx.moveTo(shape.x, shape.y + h);\n          ctx.lineTo(shape.x + w, shape.y + h);\n          ctx.lineTo(shape.x + w / 2, shape.y);\n          ctx.closePath();\n          ctx.fill();\n        } // ... (other shapes unchanged)\n        if (idx === selectedShapeIndex) {\n          ctx.strokeStyle = '#f59e42';\n          ctx.lineWidth = 2;\n          ctx.strokeRect(shape.x - 2, shape.y - 2, w + 4, h + 4);\n          drawHandles(ctx, shape.x, shape.y, w, h);\n        }\n      }\n      ctx.restore();\n    });\n    texts.forEach(({\n      text,\n      x,\n      y,\n      color,\n      w,\n      h,\n      fontSize\n    }, idx) => {\n      ctx.save();\n      ctx.font = `${fontSize || 24}px Arial`;\n      ctx.fillStyle = color;\n      ctx.fillText(text, x, y + (fontSize || 24));\n      const boxW = w !== null && w !== void 0 ? w : ctx.measureText(text).width;\n      const boxH = h !== null && h !== void 0 ? h : (fontSize || 24) + 8;\n      if (idx === selectedTextIndex) {\n        ctx.strokeStyle = '#f59e42';\n        ctx.strokeRect(x - 2, y - 2, boxW + 4, boxH + 4);\n        drawHandles(ctx, x, y, boxW, boxH);\n      }\n      ctx.restore();\n    });\n    lines.forEach(line => {\n      ctx.beginPath();\n      ctx.strokeStyle = line.mode === 'eraser' ? 'rgba(0,0,0,1)' : line.color || '#333';\n      ctx.lineWidth = line.size || 2;\n      ctx.globalCompositeOperation = line.mode === 'eraser' ? 'destination-out' : 'source-over';\n      line.points.forEach(([x, y], i) => {\n        if (i === 0) ctx.moveTo(x, y);else ctx.lineTo(x, y);\n      });\n      ctx.stroke();\n      ctx.globalCompositeOperation = 'source-over';\n    });\n  }, [shapes, texts, lines, selectedTextIndex, selectedShapeIndex]);\n  function drawHandles(ctx, x, y, w, h) {\n    const handles = [[x - HANDLE_SIZE / 2, y - HANDLE_SIZE / 2], [x + w - HANDLE_SIZE / 2, y - HANDLE_SIZE / 2], [x - HANDLE_SIZE / 2, y + h - HANDLE_SIZE / 2], [x + w - HANDLE_SIZE / 2, y + h - HANDLE_SIZE / 2]];\n    handles.forEach(([hx, hy]) => {\n      ctx.fillStyle = '#fff';\n      ctx.strokeStyle = '#333';\n      ctx.lineWidth = 1;\n      ctx.fillRect(hx, hy, HANDLE_SIZE, HANDLE_SIZE);\n      ctx.strokeRect(hx, hy, HANDLE_SIZE, HANDLE_SIZE);\n    });\n  }\n  function getHandleAt(x, y, w, h, mouseX, mouseY) {\n    const handles = [[x - HANDLE_SIZE / 2, y - HANDLE_SIZE / 2], [x + w - HANDLE_SIZE / 2, y - HANDLE_SIZE / 2], [x - HANDLE_SIZE / 2, y + h - HANDLE_SIZE / 2], [x + w - HANDLE_SIZE / 2, y + h - HANDLE_SIZE / 2]];\n    for (let i = 0; i < handles.length; i++) {\n      const [hx, hy] = handles[i];\n      if (mouseX >= hx && mouseX <= hx + HANDLE_SIZE && mouseY >= hy && mouseY <= hy + HANDLE_SIZE) {\n        return i;\n      }\n    }\n    return null;\n  }\n  const handleCanvasMouseDown = e => {\n    const mouseX = e.nativeEvent.offsetX;\n    const mouseY = e.nativeEvent.offsetY;\n    let clickedOnShapeOrHandle = false;\n\n    // Text handles\n    for (let i = texts.length - 1; i >= 0; i--) {\n      var _t$w, _t$h;\n      const t = texts[i];\n      const ctx = canvasRef.current.getContext('2d');\n      ctx.font = `${t.fontSize || 24}px Arial`;\n      const boxW = (_t$w = t.w) !== null && _t$w !== void 0 ? _t$w : ctx.measureText(t.text).width;\n      const boxH = (_t$h = t.h) !== null && _t$h !== void 0 ? _t$h : (t.fontSize || 24) + 8;\n      const handleIdx = getHandleAt(t.x, t.y, boxW, boxH, mouseX, mouseY);\n      if (i === selectedTextIndex && handleIdx !== null) {\n        setResizingHandle({\n          type: 'text',\n          idx: i,\n          handleIdx\n        });\n        clickedOnShapeOrHandle = true;\n        break;\n      }\n      if (mouseX >= t.x && mouseX <= t.x + boxW && mouseY >= t.y && mouseY <= t.y + boxH) {\n        setSelectedTextIndex(i);\n        setSelectedShapeIndex(null);\n        setDragOffset({\n          x: mouseX - t.x,\n          y: mouseY - t.y\n        });\n        setIsDragging(true);\n        clickedOnShapeOrHandle = true;\n        break;\n      }\n    }\n\n    // Shape/image handles\n    if (!clickedOnShapeOrHandle) {\n      for (let i = shapes.length - 1; i >= 0; i--) {\n        var _shape$w2, _shape$h2;\n        const shape = shapes[i];\n        const w = (_shape$w2 = shape.w) !== null && _shape$w2 !== void 0 ? _shape$w2 : getDefaultSize(shape.type).w;\n        const h = (_shape$h2 = shape.h) !== null && _shape$h2 !== void 0 ? _shape$h2 : getDefaultSize(shape.type).h;\n        const handleIdx = getHandleAt(shape.x, shape.y, w, h, mouseX, mouseY);\n        if (i === selectedShapeIndex && handleIdx !== null) {\n          setResizingHandle({\n            type: 'shape',\n            idx: i,\n            handleIdx\n          });\n          clickedOnShapeOrHandle = true;\n          break;\n        }\n        if (mouseX >= shape.x && mouseX <= shape.x + w && mouseY >= shape.y && mouseY <= shape.y + h) {\n          setSelectedShapeIndex(i);\n          setSelectedTextIndex(null);\n          setDragOffset({\n            x: mouseX - shape.x,\n            y: mouseY - shape.y\n          });\n          setIsDragging(true);\n          clickedOnShapeOrHandle = true;\n          break;\n        }\n      }\n    }\n    if (!clickedOnShapeOrHandle) {\n      setSelectedShapeIndex(null);\n      setSelectedTextIndex(null);\n    }\n    if (drawMode || eraserMode) {\n      setIsDrawing(true);\n      drawingPointsRef.current = [[mouseX, mouseY]];\n    }\n  };\n  const handleCanvasMouseMove = e => {\n    const mouseX = e.nativeEvent.offsetX;\n    const mouseY = e.nativeEvent.offsetY;\n    if (resizingHandle !== null) {\n      if (resizingHandle.type === 'shape' && resizingHandle.idx !== null) {\n        var _shape$w3, _shape$h3;\n        const shape = shapes[resizingHandle.idx];\n        const w = (_shape$w3 = shape.w) !== null && _shape$w3 !== void 0 ? _shape$w3 : getDefaultSize(shape.type).w;\n        const h = (_shape$h3 = shape.h) !== null && _shape$h3 !== void 0 ? _shape$h3 : getDefaultSize(shape.type).h;\n        let newShape = {\n          ...shape\n        };\n        if (resizingHandle.handleIdx === 0) {\n          newShape.x = mouseX;\n          newShape.y = mouseY;\n          newShape.w = w + (shape.x - mouseX);\n          newShape.h = h + (shape.y - mouseY);\n        } else if (resizingHandle.handleIdx === 1) {\n          newShape.y = mouseY;\n          newShape.w = mouseX - shape.x;\n          newShape.h = h + (shape.y - mouseY);\n        } else if (resizingHandle.handleIdx === 2) {\n          newShape.x = mouseX;\n          newShape.w = w + (shape.x - mouseX);\n          newShape.h = mouseY - shape.y;\n        } else if (resizingHandle.handleIdx === 3) {\n          newShape.w = mouseX - shape.x;\n          newShape.h = mouseY - shape.y;\n        }\n        newShape.w = Math.max(20, newShape.w);\n        newShape.h = Math.max(20, newShape.h);\n        const newShapes = shapes.map((s, idx) => idx === resizingHandle.idx ? newShape : s);\n        setHistory(h => {\n          const newHistory = h.slice(0, historyIndex + 1);\n          newHistory[historyIndex] = {\n            shapes: newShapes,\n            texts,\n            lines\n          };\n          return newHistory;\n        });\n        return;\n      }\n      if (resizingHandle.type === 'text' && resizingHandle.idx !== null) {\n        var _t$w2, _t$h2;\n        const t = texts[resizingHandle.idx];\n        const ctx = canvasRef.current.getContext('2d');\n        ctx.font = `${t.fontSize || 24}px Arial`;\n        const boxW = (_t$w2 = t.w) !== null && _t$w2 !== void 0 ? _t$w2 : ctx.measureText(t.text).width;\n        const boxH = (_t$h2 = t.h) !== null && _t$h2 !== void 0 ? _t$h2 : (t.fontSize || 24) + 8;\n        let newText = {\n          ...t\n        };\n        if (resizingHandle.handleIdx === 0) {\n          newText.x = mouseX;\n          newText.y = mouseY;\n          newText.w = boxW + (t.x - mouseX);\n          newText.h = boxH + (t.y - mouseY);\n        } else if (resizingHandle.handleIdx === 1) {\n          newText.y = mouseY;\n          newText.w = mouseX - t.x;\n          newText.h = boxH + (t.y - mouseY);\n        } else if (resizingHandle.handleIdx === 2) {\n          newText.x = mouseX;\n          newText.w = boxW + (t.x - mouseX);\n          newText.h = mouseY - t.y;\n        } else if (resizingHandle.handleIdx === 3) {\n          newText.w = mouseX - t.x;\n          newText.h = mouseY - t.y;\n        }\n        newText.w = Math.max(20, newText.w);\n        newText.h = Math.max(20, newText.h);\n        newText.fontSize = Math.max(12, newText.h - 8);\n        const newTexts = texts.map((tt, idx) => idx === resizingHandle.idx ? newText : tt);\n        setHistory(h => {\n          const newHistory = h.slice(0, historyIndex + 1);\n          newHistory[historyIndex] = {\n            shapes,\n            texts: newTexts,\n            lines\n          };\n          return newHistory;\n        });\n        return;\n      }\n    }\n    if (isDrawing && (drawMode || eraserMode)) {\n      const canvas = canvasRef.current;\n      const ctx = canvas.getContext('2d');\n      const points = drawingPointsRef.current;\n      points.push([mouseX, mouseY]);\n      ctx.beginPath();\n      ctx.moveTo(points[points.length - 2][0], points[points.length - 2][1]);\n      ctx.lineTo(mouseX, mouseY);\n      ctx.lineWidth = eraserMode ? eraserSize : brushSize;\n      ctx.strokeStyle = eraserMode ? 'rgba(0,0,0,1)' : pencilColor;\n      ctx.globalCompositeOperation = eraserMode ? 'destination-out' : 'source-over';\n      ctx.stroke();\n      ctx.globalCompositeOperation = 'source-over';\n      return;\n    }\n    if (isDragging && selectedTextIndex !== null) {\n      var _t$w3, _t$h3;\n      const t = texts[selectedTextIndex];\n      const ctx = canvasRef.current.getContext('2d');\n      ctx.font = `${t.fontSize || 24}px Arial`;\n      const boxW = (_t$w3 = t.w) !== null && _t$w3 !== void 0 ? _t$w3 : ctx.measureText(t.text).width;\n      const boxH = (_t$h3 = t.h) !== null && _t$h3 !== void 0 ? _t$h3 : (t.fontSize || 24) + 8;\n      const newTexts = texts.map((tt, idx) => idx === selectedTextIndex ? {\n        ...tt,\n        x: mouseX - dragOffset.x,\n        y: mouseY - dragOffset.y,\n        w: boxW,\n        h: boxH\n      } : tt);\n      setHistory(h => {\n        const newHistory = h.slice(0, historyIndex + 1);\n        newHistory[historyIndex] = {\n          shapes,\n          texts: newTexts,\n          lines\n        };\n        return newHistory;\n      });\n    }\n    if (isDragging && selectedShapeIndex !== null) {\n      var _shape$w4, _shape$h4;\n      const shape = shapes[selectedShapeIndex];\n      const w = (_shape$w4 = shape.w) !== null && _shape$w4 !== void 0 ? _shape$w4 : getDefaultSize(shape.type).w;\n      const h = (_shape$h4 = shape.h) !== null && _shape$h4 !== void 0 ? _shape$h4 : getDefaultSize(shape.type).h;\n      const newShapes = shapes.map((s, idx) => idx === selectedShapeIndex ? {\n        ...s,\n        x: mouseX - dragOffset.x,\n        y: mouseY - dragOffset.y,\n        w,\n        h\n      } : s);\n      setHistory(h => {\n        const newHistory = h.slice(0, historyIndex + 1);\n        newHistory[historyIndex] = {\n          shapes: newShapes,\n          texts,\n          lines\n        };\n        return newHistory;\n      });\n    }\n  };\n  const handleCanvasMouseUp = () => {\n    if (resizingHandle !== null) {\n      setResizingHandle(null);\n      saveState(shapes, texts, lines);\n      return;\n    }\n    if (isDrawing && (drawMode || eraserMode)) {\n      setIsDrawing(false);\n      const newLine = {\n        points: drawingPointsRef.current,\n        color: eraserMode ? 'eraser' : pencilColor,\n        size: eraserMode ? eraserSize : brushSize,\n        mode: eraserMode ? 'eraser' : 'draw'\n      };\n      saveState(shapes, texts, [...lines, newLine]);\n      drawingPointsRef.current = [];\n    }\n    if (isDragging && selectedTextIndex !== null) {\n      saveState(shapes, texts, lines);\n      setIsDragging(false);\n    }\n    if (isDragging && selectedShapeIndex !== null) {\n      saveState(shapes, texts, lines);\n      setIsDragging(false);\n    }\n  };\n\n  // ... (undo/redo, color, upload, download, clearCanvas, etc. unchanged)\n\n  const handleAddText = () => {\n    const text = prompt('Enter text to add:');\n    if (!text) return;\n    const ctx = canvasRef.current.getContext('2d');\n    ctx.font = '24px Arial';\n    const w = ctx.measureText(text).width;\n    const h = 32;\n    saveState(shapes, [...texts, {\n      text,\n      x: 100,\n      y: 400,\n      color: textColor,\n      w,\n      h,\n      fontSize: 24\n    }], lines);\n  };\n\n  // ... (rest of the code unchanged, including sidebar and canvas)\n};\n_s(CanvasEditor, \"0Ln5iqHDRo7B1YU36Oj6ILyp82Y=\");\n_c = CanvasEditor;\nexport default CanvasEditor;\nvar _c;\n$RefreshReg$(_c, \"CanvasEditor\");","map":{"version":3,"names":["React","useRef","useEffect","useState","drawPolygon","ctx","x","y","radius","sides","color","beginPath","i","angle","Math","PI","dx","cos","dy","sin","moveTo","lineTo","closePath","fillStyle","fill","initialState","shapes","texts","lines","HANDLE_SIZE","CanvasEditor","_s","canvasRef","fileInputRef","selectedShape","setSelectedShape","shapeColor","setShapeColor","drawMode","setDrawMode","eraserMode","setEraserMode","eraserSize","setEraserSize","textColor","setTextColor","pencilColor","setPencilColor","brushSize","setBrushSize","dragOffset","setDragOffset","selectedTextIndex","setSelectedTextIndex","selectedShapeIndex","setSelectedShapeIndex","isDragging","setIsDragging","isDrawing","setIsDrawing","resizingHandle","setResizingHandle","history","setHistory","historyIndex","setHistoryIndex","drawingPointsRef","getDefaultSize","type","w","h","canvas","current","getContext","clearRect","width","height","lineWidth","lineCap","forEach","shape","idx","_shape$w","_shape$h","save","img","window","Image","src","onload","drawImage","strokeStyle","strokeRect","drawHandles","complete","fillRect","arc","translate","scale","restore","text","fontSize","font","fillText","boxW","measureText","boxH","line","mode","size","globalCompositeOperation","points","stroke","handles","hx","hy","getHandleAt","mouseX","mouseY","length","handleCanvasMouseDown","e","nativeEvent","offsetX","offsetY","clickedOnShapeOrHandle","_t$w","_t$h","t","handleIdx","_shape$w2","_shape$h2","handleCanvasMouseMove","_shape$w3","_shape$h3","newShape","max","newShapes","map","s","newHistory","slice","_t$w2","_t$h2","newText","newTexts","tt","push","_t$w3","_t$h3","_shape$w4","_shape$h4","handleCanvasMouseUp","saveState","newLine","handleAddText","prompt","_c","$RefreshReg$"],"sources":["C:/Users/Kritika Ekka/Week-6_final_project/matty-project/client/src/components/CanvasEditor.jsx"],"sourcesContent":["import React, { useRef, useEffect, useState } from 'react';\r\n\r\nfunction drawPolygon(ctx, x, y, radius, sides, color) {\r\n  ctx.beginPath();\r\n  for (let i = 0; i < sides; i++) {\r\n    const angle = (2 * Math.PI * i) / sides - Math.PI / 2;\r\n    const dx = x + radius * Math.cos(angle);\r\n    const dy = y + radius * Math.sin(angle);\r\n    if (i === 0) ctx.moveTo(dx, dy);\r\n    else ctx.lineTo(dx, dy);\r\n  }\r\n  ctx.closePath();\r\n  ctx.fillStyle = color;\r\n  ctx.fill();\r\n}\r\n\r\nconst initialState = {\r\n  shapes: [],\r\n  texts: [],\r\n  lines: []\r\n};\r\n\r\nconst HANDLE_SIZE = 16;\r\n\r\nconst CanvasEditor = () => {\r\n  const canvasRef = useRef(null);\r\n  const fileInputRef = useRef(null);\r\n  const [selectedShape, setSelectedShape] = useState('rectangle');\r\n  const [shapeColor, setShapeColor] = useState('#4f46e5');\r\n  const [drawMode, setDrawMode] = useState(false);\r\n  const [eraserMode, setEraserMode] = useState(false);\r\n  const [eraserSize, setEraserSize] = useState(20);\r\n  const [textColor, setTextColor] = useState('#111827');\r\n  const [pencilColor, setPencilColor] = useState('#333');\r\n  const [brushSize, setBrushSize] = useState(2);\r\n  const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });\r\n  const [selectedTextIndex, setSelectedTextIndex] = useState(null);\r\n  const [selectedShapeIndex, setSelectedShapeIndex] = useState(null);\r\n  const [isDragging, setIsDragging] = useState(false);\r\n  const [isDrawing, setIsDrawing] = useState(false);\r\n  const [resizingHandle, setResizingHandle] = useState(null);\r\n  const [history, setHistory] = useState([initialState]);\r\n  const [historyIndex, setHistoryIndex] = useState(0);\r\n  const drawingPointsRef = useRef([]);\r\n\r\n  const { shapes, texts, lines } = history[historyIndex];\r\n\r\n  const getDefaultSize = (type) => {\r\n    if (type === 'rectangle') return { w: 120, h: 80 };\r\n    if (type === 'square' || type === 'circle') return { w: 100, h: 100 };\r\n    if (type === 'oval') return { w: 120, h: 80 };\r\n    if (type === 'image') return { w: 200, h: 200 };\r\n    if (type === 'text') return { w: 120, h: 32 };\r\n    return { w: 120, h: 80 };\r\n  };\r\n\r\n  useEffect(() => {\r\n    const canvas = canvasRef.current;\r\n    const ctx = canvas.getContext('2d');\r\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\r\n    ctx.lineWidth = 2;\r\n    ctx.lineCap = 'round';\r\n\r\n    shapes.forEach((shape, idx) => {\r\n      ctx.save();\r\n      const w = shape.w ?? getDefaultSize(shape.type).w;\r\n      const h = shape.h ?? getDefaultSize(shape.type).h;\r\n      if (shape.type === 'image') {\r\n        const img = new window.Image();\r\n        img.src = shape.src;\r\n        img.onload = () => {\r\n          ctx.drawImage(img, shape.x, shape.y, w, h);\r\n          if (idx === selectedShapeIndex) {\r\n            ctx.strokeStyle = '#f59e42';\r\n            ctx.lineWidth = 2;\r\n            ctx.strokeRect(shape.x - 2, shape.y - 2, w + 4, h + 4);\r\n            drawHandles(ctx, shape.x, shape.y, w, h);\r\n          }\r\n        };\r\n        if (img.complete) {\r\n          ctx.drawImage(img, shape.x, shape.y, w, h);\r\n          if (idx === selectedShapeIndex) {\r\n            ctx.strokeStyle = '#f59e42';\r\n            ctx.lineWidth = 2;\r\n            ctx.strokeRect(shape.x - 2, shape.y - 2, w + 4, h + 4);\r\n            drawHandles(ctx, shape.x, shape.y, w, h);\r\n          }\r\n        }\r\n      } else {\r\n        ctx.fillStyle = shape.color;\r\n        ctx.strokeStyle = shape.color;\r\n        if (shape.type === 'rectangle' || shape.type === 'square') {\r\n          ctx.fillRect(shape.x, shape.y, w, h);\r\n        } else if (shape.type === 'circle') {\r\n          ctx.beginPath();\r\n          ctx.arc(shape.x + w / 2, shape.y + h / 2, w / 2, 0, 2 * Math.PI);\r\n          ctx.fill();\r\n        } else if (shape.type === 'oval') {\r\n          ctx.save();\r\n          ctx.translate(shape.x + w / 2, shape.y + h / 2);\r\n          ctx.scale(1.5, 1);\r\n          ctx.beginPath();\r\n          ctx.arc(0, 0, h / 2, 0, 2 * Math.PI);\r\n          ctx.restore();\r\n          ctx.fill();\r\n        } else if (shape.type === 'triangle') {\r\n          ctx.beginPath();\r\n          ctx.moveTo(shape.x, shape.y + h);\r\n          ctx.lineTo(shape.x + w, shape.y + h);\r\n          ctx.lineTo(shape.x + w / 2, shape.y);\r\n          ctx.closePath();\r\n          ctx.fill();\r\n        } // ... (other shapes unchanged)\r\n        if (idx === selectedShapeIndex) {\r\n          ctx.strokeStyle = '#f59e42';\r\n          ctx.lineWidth = 2;\r\n          ctx.strokeRect(shape.x - 2, shape.y - 2, w + 4, h + 4);\r\n          drawHandles(ctx, shape.x, shape.y, w, h);\r\n        }\r\n      }\r\n      ctx.restore();\r\n    });\r\n\r\n    texts.forEach(({ text, x, y, color, w, h, fontSize }, idx) => {\r\n      ctx.save();\r\n      ctx.font = `${fontSize || 24}px Arial`;\r\n      ctx.fillStyle = color;\r\n      ctx.fillText(text, x, y + (fontSize || 24));\r\n      const boxW = w ?? ctx.measureText(text).width;\r\n      const boxH = h ?? (fontSize || 24) + 8;\r\n      if (idx === selectedTextIndex) {\r\n        ctx.strokeStyle = '#f59e42';\r\n        ctx.strokeRect(x - 2, y - 2, boxW + 4, boxH + 4);\r\n        drawHandles(ctx, x, y, boxW, boxH);\r\n      }\r\n      ctx.restore();\r\n    });\r\n\r\n    lines.forEach(line => {\r\n      ctx.beginPath();\r\n      ctx.strokeStyle = line.mode === 'eraser' ? 'rgba(0,0,0,1)' : line.color || '#333';\r\n      ctx.lineWidth = line.size || 2;\r\n      ctx.globalCompositeOperation = line.mode === 'eraser' ? 'destination-out' : 'source-over';\r\n      line.points.forEach(([x, y], i) => {\r\n        if (i === 0) ctx.moveTo(x, y);\r\n        else ctx.lineTo(x, y);\r\n      });\r\n      ctx.stroke();\r\n      ctx.globalCompositeOperation = 'source-over';\r\n    });\r\n  }, [shapes, texts, lines, selectedTextIndex, selectedShapeIndex]);\r\n\r\n  function drawHandles(ctx, x, y, w, h) {\r\n    const handles = [\r\n      [x - HANDLE_SIZE / 2, y - HANDLE_SIZE / 2],\r\n      [x + w - HANDLE_SIZE / 2, y - HANDLE_SIZE / 2],\r\n      [x - HANDLE_SIZE / 2, y + h - HANDLE_SIZE / 2],\r\n      [x + w - HANDLE_SIZE / 2, y + h - HANDLE_SIZE / 2]\r\n    ];\r\n    handles.forEach(([hx, hy]) => {\r\n      ctx.fillStyle = '#fff';\r\n      ctx.strokeStyle = '#333';\r\n      ctx.lineWidth = 1;\r\n      ctx.fillRect(hx, hy, HANDLE_SIZE, HANDLE_SIZE);\r\n      ctx.strokeRect(hx, hy, HANDLE_SIZE, HANDLE_SIZE);\r\n    });\r\n  }\r\n\r\n  function getHandleAt(x, y, w, h, mouseX, mouseY) {\r\n    const handles = [\r\n      [x - HANDLE_SIZE / 2, y - HANDLE_SIZE / 2],\r\n      [x + w - HANDLE_SIZE / 2, y - HANDLE_SIZE / 2],\r\n      [x - HANDLE_SIZE / 2, y + h - HANDLE_SIZE / 2],\r\n      [x + w - HANDLE_SIZE / 2, y + h - HANDLE_SIZE / 2]\r\n    ];\r\n    for (let i = 0; i < handles.length; i++) {\r\n      const [hx, hy] = handles[i];\r\n      if (\r\n        mouseX >= hx && mouseX <= hx + HANDLE_SIZE &&\r\n        mouseY >= hy && mouseY <= hy + HANDLE_SIZE\r\n      ) {\r\n        return i;\r\n      }\r\n    }\r\n    return null;\r\n  }\r\n\r\n  const handleCanvasMouseDown = (e) => {\r\n    const mouseX = e.nativeEvent.offsetX;\r\n    const mouseY = e.nativeEvent.offsetY;\r\n    let clickedOnShapeOrHandle = false;\r\n\r\n    // Text handles\r\n    for (let i = texts.length - 1; i >= 0; i--) {\r\n      const t = texts[i];\r\n      const ctx = canvasRef.current.getContext('2d');\r\n      ctx.font = `${t.fontSize || 24}px Arial`;\r\n      const boxW = t.w ?? ctx.measureText(t.text).width;\r\n      const boxH = t.h ?? (t.fontSize || 24) + 8;\r\n      const handleIdx = getHandleAt(t.x, t.y, boxW, boxH, mouseX, mouseY);\r\n      if (i === selectedTextIndex && handleIdx !== null) {\r\n        setResizingHandle({ type: 'text', idx: i, handleIdx });\r\n        clickedOnShapeOrHandle = true;\r\n        break;\r\n      }\r\n      if (\r\n        mouseX >= t.x &&\r\n        mouseX <= t.x + boxW &&\r\n        mouseY >= t.y &&\r\n        mouseY <= t.y + boxH\r\n      ) {\r\n        setSelectedTextIndex(i);\r\n        setSelectedShapeIndex(null);\r\n        setDragOffset({ x: mouseX - t.x, y: mouseY - t.y });\r\n        setIsDragging(true);\r\n        clickedOnShapeOrHandle = true;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // Shape/image handles\r\n    if (!clickedOnShapeOrHandle) {\r\n      for (let i = shapes.length - 1; i >= 0; i--) {\r\n        const shape = shapes[i];\r\n        const w = shape.w ?? getDefaultSize(shape.type).w;\r\n        const h = shape.h ?? getDefaultSize(shape.type).h;\r\n        const handleIdx = getHandleAt(shape.x, shape.y, w, h, mouseX, mouseY);\r\n        if (i === selectedShapeIndex && handleIdx !== null) {\r\n          setResizingHandle({ type: 'shape', idx: i, handleIdx });\r\n          clickedOnShapeOrHandle = true;\r\n          break;\r\n        }\r\n        if (\r\n          mouseX >= shape.x &&\r\n          mouseX <= shape.x + w &&\r\n          mouseY >= shape.y &&\r\n          mouseY <= shape.y + h\r\n        ) {\r\n          setSelectedShapeIndex(i);\r\n          setSelectedTextIndex(null);\r\n          setDragOffset({ x: mouseX - shape.x, y: mouseY - shape.y });\r\n          setIsDragging(true);\r\n          clickedOnShapeOrHandle = true;\r\n          break;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (!clickedOnShapeOrHandle) {\r\n      setSelectedShapeIndex(null);\r\n      setSelectedTextIndex(null);\r\n    }\r\n    if (drawMode || eraserMode) {\r\n      setIsDrawing(true);\r\n      drawingPointsRef.current = [[mouseX, mouseY]];\r\n    }\r\n  };\r\n\r\n  const handleCanvasMouseMove = (e) => {\r\n    const mouseX = e.nativeEvent.offsetX;\r\n    const mouseY = e.nativeEvent.offsetY;\r\n    if (resizingHandle !== null) {\r\n      if (resizingHandle.type === 'shape' && resizingHandle.idx !== null) {\r\n        const shape = shapes[resizingHandle.idx];\r\n        const w = shape.w ?? getDefaultSize(shape.type).w;\r\n        const h = shape.h ?? getDefaultSize(shape.type).h;\r\n        let newShape = { ...shape };\r\n        if (resizingHandle.handleIdx === 0) {\r\n          newShape.x = mouseX;\r\n          newShape.y = mouseY;\r\n          newShape.w = w + (shape.x - mouseX);\r\n          newShape.h = h + (shape.y - mouseY);\r\n        } else if (resizingHandle.handleIdx === 1) {\r\n          newShape.y = mouseY;\r\n          newShape.w = mouseX - shape.x;\r\n          newShape.h = h + (shape.y - mouseY);\r\n        } else if (resizingHandle.handleIdx === 2) {\r\n          newShape.x = mouseX;\r\n          newShape.w = w + (shape.x - mouseX);\r\n          newShape.h = mouseY - shape.y;\r\n        } else if (resizingHandle.handleIdx === 3) {\r\n          newShape.w = mouseX - shape.x;\r\n          newShape.h = mouseY - shape.y;\r\n        }\r\n        newShape.w = Math.max(20, newShape.w);\r\n        newShape.h = Math.max(20, newShape.h);\r\n        const newShapes = shapes.map((s, idx) =>\r\n          idx === resizingHandle.idx ? newShape : s\r\n        );\r\n        setHistory(h => {\r\n          const newHistory = h.slice(0, historyIndex + 1);\r\n          newHistory[historyIndex] = { shapes: newShapes, texts, lines };\r\n          return newHistory;\r\n        });\r\n        return;\r\n      }\r\n      if (resizingHandle.type === 'text' && resizingHandle.idx !== null) {\r\n        const t = texts[resizingHandle.idx];\r\n        const ctx = canvasRef.current.getContext('2d');\r\n        ctx.font = `${t.fontSize || 24}px Arial`;\r\n        const boxW = t.w ?? ctx.measureText(t.text).width;\r\n        const boxH = t.h ?? (t.fontSize || 24) + 8;\r\n        let newText = { ...t };\r\n        if (resizingHandle.handleIdx === 0) {\r\n          newText.x = mouseX;\r\n          newText.y = mouseY;\r\n          newText.w = boxW + (t.x - mouseX);\r\n          newText.h = boxH + (t.y - mouseY);\r\n        } else if (resizingHandle.handleIdx === 1) {\r\n          newText.y = mouseY;\r\n          newText.w = mouseX - t.x;\r\n          newText.h = boxH + (t.y - mouseY);\r\n        } else if (resizingHandle.handleIdx === 2) {\r\n          newText.x = mouseX;\r\n          newText.w = boxW + (t.x - mouseX);\r\n          newText.h = mouseY - t.y;\r\n        } else if (resizingHandle.handleIdx === 3) {\r\n          newText.w = mouseX - t.x;\r\n          newText.h = mouseY - t.y;\r\n        }\r\n        newText.w = Math.max(20, newText.w);\r\n        newText.h = Math.max(20, newText.h);\r\n        newText.fontSize = Math.max(12, newText.h - 8);\r\n        const newTexts = texts.map((tt, idx) =>\r\n          idx === resizingHandle.idx ? newText : tt\r\n        );\r\n        setHistory(h => {\r\n          const newHistory = h.slice(0, historyIndex + 1);\r\n          newHistory[historyIndex] = { shapes, texts: newTexts, lines };\r\n          return newHistory;\r\n        });\r\n        return;\r\n      }\r\n    }\r\n    if (isDrawing && (drawMode || eraserMode)) {\r\n      const canvas = canvasRef.current;\r\n      const ctx = canvas.getContext('2d');\r\n      const points = drawingPointsRef.current;\r\n      points.push([mouseX, mouseY]);\r\n      ctx.beginPath();\r\n      ctx.moveTo(points[points.length - 2][0], points[points.length - 2][1]);\r\n      ctx.lineTo(mouseX, mouseY);\r\n      ctx.lineWidth = eraserMode ? eraserSize : brushSize;\r\n      ctx.strokeStyle = eraserMode ? 'rgba(0,0,0,1)' : pencilColor;\r\n      ctx.globalCompositeOperation = eraserMode ? 'destination-out' : 'source-over';\r\n      ctx.stroke();\r\n      ctx.globalCompositeOperation = 'source-over';\r\n      return;\r\n    }\r\n    if (isDragging && selectedTextIndex !== null) {\r\n      const t = texts[selectedTextIndex];\r\n      const ctx = canvasRef.current.getContext('2d');\r\n      ctx.font = `${t.fontSize || 24}px Arial`;\r\n      const boxW = t.w ?? ctx.measureText(t.text).width;\r\n      const boxH = t.h ?? (t.fontSize || 24) + 8;\r\n      const newTexts = texts.map((tt, idx) =>\r\n        idx === selectedTextIndex ? { ...tt, x: mouseX - dragOffset.x, y: mouseY - dragOffset.y, w: boxW, h: boxH } : tt\r\n      );\r\n      setHistory(h => {\r\n        const newHistory = h.slice(0, historyIndex + 1);\r\n        newHistory[historyIndex] = { shapes, texts: newTexts, lines };\r\n        return newHistory;\r\n      });\r\n    }\r\n    if (isDragging && selectedShapeIndex !== null) {\r\n      const shape = shapes[selectedShapeIndex];\r\n      const w = shape.w ?? getDefaultSize(shape.type).w;\r\n      const h = shape.h ?? getDefaultSize(shape.type).h;\r\n      const newShapes = shapes.map((s, idx) =>\r\n        idx === selectedShapeIndex ? { ...s, x: mouseX - dragOffset.x, y: mouseY - dragOffset.y, w, h } : s\r\n      );\r\n      setHistory(h => {\r\n        const newHistory = h.slice(0, historyIndex + 1);\r\n        newHistory[historyIndex] = { shapes: newShapes, texts, lines };\r\n        return newHistory;\r\n      });\r\n    }\r\n  };\r\n\r\n  const handleCanvasMouseUp = () => {\r\n    if (resizingHandle !== null) {\r\n      setResizingHandle(null);\r\n      saveState(shapes, texts, lines);\r\n      return;\r\n    }\r\n    if (isDrawing && (drawMode || eraserMode)) {\r\n      setIsDrawing(false);\r\n      const newLine = {\r\n        points: drawingPointsRef.current,\r\n        color: eraserMode ? 'eraser' : pencilColor,\r\n        size: eraserMode ? eraserSize : brushSize,\r\n        mode: eraserMode ? 'eraser' : 'draw'\r\n      };\r\n      saveState(shapes, texts, [...lines, newLine]);\r\n      drawingPointsRef.current = [];\r\n    }\r\n    if (isDragging && selectedTextIndex !== null) {\r\n      saveState(shapes, texts, lines);\r\n      setIsDragging(false);\r\n    }\r\n    if (isDragging && selectedShapeIndex !== null) {\r\n      saveState(shapes, texts, lines);\r\n      setIsDragging(false);\r\n    }\r\n  };\r\n\r\n  // ... (undo/redo, color, upload, download, clearCanvas, etc. unchanged)\r\n\r\n  const handleAddText = () => {\r\n    const text = prompt('Enter text to add:');\r\n    if (!text) return;\r\n    const ctx = canvasRef.current.getContext('2d');\r\n    ctx.font = '24px Arial';\r\n    const w = ctx.measureText(text).width;\r\n    const h = 32;\r\n    saveState(shapes, [...texts, { text, x: 100, y: 400, color: textColor, w, h, fontSize: 24 }], lines);\r\n  };\r\n\r\n  // ... (rest of the code unchanged, including sidebar and canvas)\r\n};\r\n\r\nexport default CanvasEditor;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}